\documentclass{article}

\usepackage{graphicx}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{svg}
\usepackage{float}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[inner=3cm, outer=3cm, top=2cm, bottom=2.5cm]{geometry}

\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle}

\hbadness=10001
\hfuzz=4pt
\vfuzz=4pt

\title{Informatik}
\date{Q2 2022/2023}
\author{Paul SK \& Sophie}

\begin{document}
	\pagenumbering{gobble}
	\maketitle
	\newpage

	\pagenumbering{arabic}

	\section{Allgemeines}
	\subsection{Dokumentationen}
	Eine vollständige Dokumentation sämtlicher Abiturrelevanter Klassen kann \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp\_SII/if/Dokumentation\_ZA-IF\_GK-LK\_ab\_2018\_2021\_12\_22.pdf}{\underline{hier gefunden werden}}.

	\section{OOP mit Java}

	\section{Lineare Datenstrukturen}

	\section{Algorithmen}

	\section{Datenbanken}
	\subsection{Das Entity-Relationship-Modell}
	\subsubsection{Verschiedene Elemente}
	\paragraph{Entität}
	Durch eine Entität werden generelle "Dinge" abstrahiert, wie zum Beispiel Menschen, Räume, Computer usw.

	\begin{figure}[h!]
		\centering
		\includesvg[width=3.0cm]{entity}
		\caption{Eine Entität wird mit einem Rechteck dargestellt}
	\end{figure}	

	\paragraph{Attribut}
	Attribute beschreiben die Eigenschaften einer Entität. Wenn ein Attribut ein sogenannter Primärschlüssel ist, der eindeutig der Instanz einer Entität zuzuordnen ist, wird dieser unterstrichen.

	\begin{figure}[h!]
		\centering
		\includesvg[width=3.0cm]{attribute}
		\caption{Ein Attribut wird in einer Ellipse geschrieben}
	\end{figure}	

	\paragraph{Relation}
	Mithilfe von Relationen werden die Beziehungen zwischen zwei Entitäten beschrieben. Wenn ich beispielsweise sagen möchte, dass einem Menschen ein Auto gehört, stelle ich eine Relation zwischen den Entitäten "Mensch" und "Auto" her. Darüber hinaus kann eine Relation auch Attribute haben, die die Beziehung in irgendeiner Form beschreiben.
	Relationen haben immer sogenannte "Kardinalitäten". Damit wird die Menge der Beziehungen beschrieben, die zwei Entitäten haben. Davon gibt es drei Stück:

	\subparagraph{1-zu-1-Relation}
	Bei 1 zu 1 Relationen hat eine Instanz einer Entität exakt eine Beziehung zu der Instanz einer anderen Entität. Beispielsweise hat ein Mitarbeiter genau einen Firmenwagen, und jeder Firmenwagen gehört auch nur zu einem Mitarbeiter.

	\subparagraph{1-zu-n-Beziehung}
	Eine 1 zu n Beziehung beschreibt Umstände, bei denen die Instanz einer Entität mehrere Beziehungen zu verschiedenen Instanzen einer anderen Entität hat. Die Instanzen der zweiten Entität wiederum haben aber jeweils nur eine Beziehung zu der ersten Entität. Beispielsweise gehören hat die Schulklasse "7b" 20 Schüler, und jeder diese Schüler gehört zu der einen Schulklasse "7b".

	\subparagraph{n-zu-m-Beziehung}
	n zu m Relationen beschreiben Beziehungen, in denen eine Entität sich auf mehrere Instanzen anderer Entitäten beziehen kann und eine Instanz der zweiten Entität sich auch wieder auf mehrere Instanzen aus der ersten Entität bezieht. Ein Bespiel hierfür wäre eine Entität "Lehrer", deren Instanz viele Schüler unterricht (n) und Instanzen der Klasse Schüler, die von vielen verschiedenen Lehrern unterrichtet werden (m).

	Die Kardinalitäten stehen im ER-Diagramm immer von der einen Entität in Richtung einer zweiten Entität auf der Rautenseite bei der zweiten Entität.

	\begin{figure}[h!]
		\centering
		\includesvg[width=3.0cm]{relation}
		\caption{Ein Relation wird durch eine Raute repräsentiert}
	\end{figure}

	\subsubsection{Transformation}
	Bei der Transformation überführen wir ein ER-Diagramm in eine Tabellenform, die wir für eine relationale Datenbank verwenden können.
	Eine Tabelle wird wie folgt dargstellt:
	\begin{center}
		Mensch(\underline{MenschId}, Name, Geschlecht) \\
		Auto(\underline{AutoId}, Modell, Kennzeichen, $\uparrow$ MenschId)
	\end{center}
	Unterstrichene Attribute sind Primärschlüssel, Attribute mit einem nach oben zeigenden Pfeil sind Fremdschlüssel.

	\paragraph{Tranformationsregeln}
	Ein ER-Diagramm wird anhand von festen Regeln in eine Tabellenform tranformiert.

	\subparagraph{Regel 1}
	Jede Entität wird als eigene Tabelle mit Primärschlüssel dargestellt.

	\subparagraph{Regel 2}
	Jede n:m-Beziehung wird als eigene Tabelle dargestellt.

	\subparagraph{Regel 3}
	Jede 1:n- und 1:1-Beziehung mit eigenen Attributen wird wie bei Regel 2 durch eine eigene Tabelle repräsentiert.

	\subparagraph{Regel 4a}
	Jede 1:n-Beziehung ohne eigene Attribute wird so dargstellt, dass der Primärschlüssel der 1-Entität Fremdschlüssel der n-Entität wird.

	\subparagraph{Regel 4b}
	Jede 1:1-Beziehung ohne eigene Attribute wird so dargstellt, dass der Primärschlüssel der ersten Entität bei der zweiten Entität Primär- und Fremdschlüssel zugleich wird.

	\subparagraph{Regel 4c}
	Sind Regel 4a und 4b nicht anwendbar, dann wird für die Beziehung eine gesonderte Tabelle angelegt. Diese Fälle müssen aus dem Kontext abgeleitet werden.
	Beispielsweise kann eine 1:1-Relation "verheiratet mit" zwischen zwei Menschen nicht durch Regel 4b gelöst werden, da sonst eine "Heiratspflicht" bestehen würde.

	\subsection{Normalisierung}
	Wenn man einfach die Tabellen verwendet, die aus der Transformation eines ER-Diagrammes resultieren, kann es zu verschiedenen Problemen kommen. Insbesondere können sogenannte "Anomalien" auftreten:

	\paragraph{Einfügeanomalie}
	Das hinzufügen eines Eintrages in eine Tabelle kann zu einem unvollständigen Datensatz führen (unerwünschte null-werte).

	\paragraph{Änderungsanomalie}
	Wenn ein Wert, der mehrfach auftritt, nur an einer Stelle geändert wird, kann diese Änderung zu einem inkonsistenten Datensatz führen.

	\paragraph{Löschanomalie}
	Das Löschen eines Datensatzes führt aufgrund von Abhängigkeiten zur (unabsichtlichen) Löschung eines weiteren Datensatzes.

	Aus diesem Grund führen wir sogenannte Normalisierungen durch, durch die solche Anomalien verhindert werden.

	\subsubsection{Erste Normalform}
	Um die erste Normalform zu erreichen, müssen alle Attribute normalisiert werden. Das bedeutet, dass alle Attribute so weit wie möglich zerlegt werden.
	Beispielsweise könnte das Attribut "Name" in "Vorname" und "Nachname" zerlegt werden.

	\subsubsection{Zweite Normalform}
	Für die zweite Normalform ordnen wir verschiedene Attribute einzelnen festen Schlüsseln zu. Dadurch könnte es notwendig sein, Relationen zu zerlegen. Die zweite Normalform ist dann gegeben, wenn die erste Normalform vorliegt und jedes Attribut, das nicht zum Primärschlüssel gehört, von diesem voll funktional abhängig ist. Jeder Datensatz bildet dann exakt einen Sachverhalt ab.

	\subsubsection{Dritte Normalform}
	Im Zuge der Normalisierung werden zuletzt sogenannte "transitive Abhängigkeiten" aufgelöst. Das bedeutet, dass wir Abhängigkeiten auflösen, bei denen ein Nichtschlüsselattribut von einem anderen Nichtschlüsselattribut und somit nur indirekt vom Primärschlüssel abhängt. Diese Abhängigkeiten werden dann auch in eine neue Tabelle ausgelagert. Ein Beispiel wäre die Abhängigkeit von einer Postleitzahl zu einem Ort.

	\subsection{Funktionale Abhängigkeiten}
	Eine funktionale Abhängigkeit liegt vor, wenn ein Attribut eindeutig ein anderes Attribut bestimmt. Geschrieben wird so eine Abhängigkeit

	\begin{equation*}
		A \rightarrow B
	\end{equation*}

	Wenn $A$ also in zwei Zelle auftritt, muss $B$ auch übereinstimmen
	Wenn es also mehrere Zellen mit dem Wer $A$ auftreten, entstehen Redundanzen. Ein Primärschlüssel bestimmt jedes Attribut eindeutig. Dementsprechend müssen zwei Zeilen identisch sein, wenn sie den gleichen Schlüssel haben. Bei einem Datenbankentwurf ist es wichtig festzulegen, welche funktionalen Abhängigkeiten gelten sollen.

	\subsection{SQL}
	SQL ist die Sprache, über die wir mit einer Datenbank interagieren können. Mit SQL können wir die klassichen CRUD-Operationen (Create, Read, Update, Delete) sowie weitere Aktionen durchführen. SQL hier komplett abzubilden würde den Rahmen sprengen, daher hier nur die "Basics". Weiterführende Infos sind beispielsweise bei w3schools.com zu finden: https://www.w3schools.com/sql/

	\subsubsection{SELECT-Queries}
	Mit den SELECT-Queries können wir Daten aus der Datenbank abfragen
	
	\paragraph{Syntax}
	\begin{lstlisting}[language=SQL]
	SELECT [spalten] FROM [tabelle]; 
	\end{lstlisting}
	Das Semikolon ist in manchen Datenbanken optional. Dennoch schreiben wir es hier der Vollständigkeit halber dazu. Ein Beispiel für eine Query unter der angegebenen Synatx wäre

	\begin{lstlisting}[language=SQL]
	SELECT vorname, nachname, beruf FROM menschen;
	\end{lstlisting}

	Diese Query fragt die Spalten "Name", "Alter" und "Beruf" aus der Tabelle "Mensch" ab.
	Statt der Attribute können wir auch ein Sternchen (*) verwenden. Dadurch fragen wir direkt alle Spalten ab.

	\paragraph{WHERE-Bedingungen}
	Bei den Queries, die wir uns bisher angesehen haben, fragen wir immer direkt alle Zeilen ab. Eventuell wollen wir aber nur bestimmte Zeilen abfragen, in denen bestimmte Bedingungen erfüllt werden. Beispielsweise wollen wir aus einer Tabelle mit Kunden nur diejenigen Kunden erhalten, die mit Vornamen "Jürgen" heißen. Dies können wir einfach mit einer WHERE-Klausel realisieren:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE vorname = 'Juergen';
	\end{lstlisting}

	Bei WHERE-Klauseln müssen Textwerte in einzelnen Anführungszeichen angegeben werden. Numerische Werte benötigen diese nicht:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE plz = 52349;
	\end{lstlisting}

	Neben dem Gleichheitszeichen gibt es eine Vielzahl weiterer sogenannter Vergleichsoperatoren:

	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | c |}
			\hline 
			\textbf{Operator} & \textbf{Beschreibung} \\
			\hline
			\hline
			\textbf{$=$} & Ist gleich \\
			\textbf{$>$} & Größer als \\
			\textbf{$<$} & Kleiner als \\
			\textbf{$>=$} & Größer oder gleich \\
			\textbf{$<=$} & Kleiner oder gleich \\
			\textbf{$<>$} & Nicht gleich \\
			\hline
		\end{tabular}
	\end{center}

	Darüber hinaus gibt es noch drei Sonderoperatoren:

	\subparagraph{LIKE-Operator}
	Mit dem LIKE-Operator können quasi Schemata bzw. Vorlagen abgefragt werden. Beispielsweise möchten wir alle Kunden abfragen, deren Vorname mit "a" beginnt.
	Um den LIKE-Operator verwenden zu können, müssen wir Platzhalter (engl. wildcards) verwenden:
	
	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | c |}
			\hline
			\textbf{Symbol} & \textbf{Beschreibung} \\
			\hline
			\hline
			\textbf{\%} & Eines oder mehrere zeichen \\
			\textbf{\_} & Ein einzelnes Zeichen \\
			\textbf{[ ]} & Irgendeines der Zeichen in den Klammern \\
			\textbf{\^ [  ]} & Ein Zeichen, das nicht in den Klammern steht \\
			\textbf{[x-y]} & Ein Zeichen in dem angegebenen Bereich \\
			\hline
		\end{tabular}
	\end{center}

	Wenn wir also alle Kunden finden wollen, deren Vorname mit "a" beginnt, nutzen wir folgende Abfrage:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE vorname LIKE 'a%';
	\end{lstlisting}

	Für alle Kunden, deren Vorname an zweiter Stelle ein a, b oder c hat, sagen wir:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE vorname LIKE '_[a-c]%';
	\end{lstlisting}

	\subparagraph{IN-Operator}
	Mit dem IN-Operator können wir abfragen, ob ein Wert in einer bestimmten Menge liegt. Wenn wir also alle Kunden haben möchten, die in den Orten mit den Postleitzahlen 52349, 52399 oder 52351 wohnen, fragen wir:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE plz IN (52349, 52399, 52351);
	\end{lstlisting}

	\subparagraph{BETWEEN-Operator}
	Mit dem BETWEEN-Operator können wir fragen, ob ein Wert zwischen zwei anderen Werten liegt. Die beiden Werte sind dabei inklusiv:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE kundennummer BETWEEN 69 AND 420;
	\end{lstlisting}

	Darüber hinaus können wir mehrere WHERE-Klauseln kombinieren:

	\subparagraph{AND-Operator}
	Über AND können wir zwei WHERE-Abfragen so kombinieren, dass die Zeile dann ausgegeben wird, wenn \underline{alle} Bedingungen zutreffen:

	\begin{lstlisting}[language=SQL, caption=Abfrage aller Kunden namens "Jürgen" in 52399]
	SELECT * FROM kunden WHERE vorname = 'Juergen' AND plz = 52399;
	\end{lstlisting}

	\subparagraph{OR-Operator}
	Bei OR werden alle Zeilen ausgegeben, in denen \underline{eine} der Bedingungen zutrifft :

	\begin{lstlisting}[language=SQL, caption=Abfrage aller Kunden mit Vorname "Jürgen" oder PLZ 52341]
	SELECT * FROM kunden WHERE vorname = 'Juergen' OR plz = 52341;
	\end{lstlisting}

	\subparagraph{NOT-Operator}
	Der NOT-Operator ist dann erfüllt, wenn eine WHERE-Bedingung nicht zutrifft:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE NOT vorname = 'Jurgen';
	\end{lstlisting}

	\paragraph{DISTINCT}
	Das DISTINCT-Statement sorgt dafür, dass wir nur untunterschiedliche Werte aus den angegebenen Spalten bekommen:

	\begin{lstlisting}[language=SQL, caption=Postleitzahlen aller Orte mit registrierten Kunden]
	SELECT DISTINCT plz FROM kunden;
	\end{lstlisting}

	\paragraph{ORDER BY}
	Über das ORDER BY-Statement können wir eine Reihenfolge angeben, in der wir die Daten sortieren möchten. Die Reihenfolge ist je nach Zusatz ASC (ascending) oder DESC (descending) aufsteigend oder absteigend:

	\begin{lstlisting}[language=SQL, caption=Vorname und PLZ aller Kunden absteigend sortiert anhand der PLZ]
	SELECT vorname, plz FROM kunden ORDER BY plz DESC;
	\end{lstlisting}

	\paragraph{Aggregatfunktionen}
	Mit Aggregatfunktionen können wir bestimmte Operationen auf unsere abgefragten Daten anwenden. Diese Funktionen rufen wir auf bestimmte Spalten in unserer Tabelle auf:

	\subparagraph{COUNT()}
	Mit COUNT() können wir die Anzahl der abgefragten Zeilen zählen:

	\begin{lstlisting}[language=SQL, caption=Anzahl aller Kunden mit dem Vornamen "Jürgen"]
	SELECT COUNT(*) FROM kunden WHERE vorname = 'Juergen';
	\end{lstlisting}

	\subparagraph{AVG()}
	AVG() berechnet den Durchschnitt der Werte in der angegebenen Spalte.

	\begin{lstlisting}[language=SQL, caption=Durchschnittliche Bestellungen eines Kunden]
	SELECT AVG(bestellungen) FROM kunden;
	\end{lstlisting}

	\subparagraph{SUM()}
	SUM() summiert alle Werte in der angegebenen Spalte auf:

	\begin{lstlisting}[language=SQL, caption=Anzahl der Bestellungen aller Kunden]
	SELECT SUM(bestellungen) FROM kunden;
	\end{lstlisting}

	\subparagraph{MIN()}
	MIN() findet den kleinsten Wert in der angegebenen Spalte:

	\begin{lstlisting}[language=SQL, caption=Kleinste Anzahl an Bestellungen eines Kunden]
	SELECT MIN(bestellungen) FROM kunden;
	\end{lstlisting}

	\subparagraph{MAX()}
	MAX() findet dementsprechend den größten Wert in der angegebenen Spalte:

	\begin{lstlisting}[language=SQL, caption=Einzelner Kunde mit den meisten Bestellungen]
	SELECTMAX(bestellungen) FROM kunden;
	\end{lstlisting}

	\paragraph{Aliasse}
	Wir können Spalten mit dem "AS"-Statement einen temporären, individuellen Namen geben:

	\begin{lstlisting}[language=SQL, caption=Benennt die Spalte "plz" in "postleitzahl" um]
	SELECT plz AS postleitzahl FROM kunden;
	\end{lstlisting}

	\paragraph{GROUP BY}
	Durch das GROUP BY-Statement können wir Zeilen mit denselben Werten gruppieren. Diese Statements werden häufig mit Aggregatfunktionen zusammen verwendet:

	\begin{lstlisting}[language=SQL, caption=Nennt die Zahl der Kunden in den einzelnen Orten]
	SELECT COUNT(kundennummer), plz FROM kunden GROUP BY plz;
	\end{lstlisting}

	\paragraph{HAVING}
	Das HAVING-Statement ist quasi ein WHERE-Statement für GROUP-BY-Abfragen, da WHERE nicht mit Aggregatfunktionen arbeiten kann:

	\begin{lstlisting}[language=SQL, caption=Orte mit mehr als 5 Kunden]
	SELECT COUNT(kundennummer), plz 
	FROM kunden 
	GROUP BY plz 
	HAVING COUNT(kundennummer) > 5;
	\end{lstlisting}

	\paragraph{Joins}
	Mit den Join-Statements können wir mehrere Tabellen miteinander verknüpfen. Um das zu verdeutlichen, erstellen wir uns zunächst zwei Tabellen "Kunden" und "Orte":

	\begin{center}
		Kunden(\underline{Kundennummer}, Vorname, Name, Bestellungen, $\uparrow$ PLZ) \\
		Orte(\underline{PLZ}, Name)
	\end{center}

	PLZ ist also für "Kunden" ein Fremdschlüssel, der auf die Tabelle "Orte" verweist. Darüber können wir die beiden Tabellen verknüpfen:

	\begin{lstlisting}[language=SQL, caption=Wir erhalten Vornamen sowie Kundennummern und dazugehörige Ortsnamen]
	SELECT kunden.vorname, kunden.kundennummer 
	FROM kunden
	INNER JOIN orte ON kunden.plz = orte.plz;
	\end{lstlisting}

	Hierbei gibt es allerdings mehrere Arten von JOIN-Statements:

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{inner_join}
		\caption{INNER JOIN gibt Einträge mit zutreffenden Werten in beiden Tabellen zurück}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{left_join}
		\caption{LEFT JOIN gibt alle Einträge aus der linken Tabelle und Einträge mit zutreffenden Werten aus der rechten Tabelle zurück}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{right_join}
		\caption{RIGHT JOIN funktioniert wie LEFT JOIN, nur umgekehrt}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{full_join}
		\caption{FULL JOIN gibt alle Einträge aus der linken und rechten Tabelle zurück, wenn es in einer der Tabellen einen zutreffenden Wert gibt}
	\end{figure}

	\paragraph{SELECT IN SELECT}
	Wir können SELECT-Abfragen nicht nur auf Tabellen, sondern auch auf andere SELECT-Abfragen ausführen:

	\begin{lstlisting}[language=SQL]
	SELECT kundennummer from (
		SELECT * FROM kunden
	);
	\end{lstlisting}

	\paragraph{UNION}
	Mit dem UNION-Statement können wir die Ergebnisse zweier SELECT-Abfragen kombinieren. Beide SELECT-Statements müssen dabei gleich viele Spalten mit gleichen Datentypen angeben.
	Als Beispiel fügen wir zu unseren Tabellen "Kunden" und "Orte" eine Tabelle "Zulieferer" hinzu:

	\begin{center}
		Zulieferer(\underline{ZuliefererId}, Firmenname, Produkt, $\uparrow$ PLZ) \\
	\end{center}

	Nun könnten wir die PLZs aus den Tabellen "Kunden" und "Zulieferer" zusammenführen:

	\begin{lstlisting}[language=SQL, caption=Wir sammeln sämtliche momentan benutzten PLZs in unserer Datenbank ein]
	SELECT plz FROM kunden
	UNION
	SELECT plz FROM zulieferer;
	\end{lstlisting}

	Dies unterscheidet sich von einer einfachen SELECT-Abfrage sämtlicher Postleitzahlen in "Orte" insofern, dass "Orte" auch Postleitzahlen enthalten kann, deren zugehörige Kunden und Zuliefrer schon gelöscht wurden. Dadurch erhalten wir nur die PLZs, die momentan wirklich verwendet werden.

	\subsubsection{INSERT INTO}
	Mit dem INSERT INTO-Statement können wir neue Einträge zu unserer Datenbank hinzufügen:

	\begin{lstlisting}[language=SQL, caption=Wir fügen neue Einträge zu der Kunden-Tabelle hinzu]
	INSERT INTO kunden (vorname, name, bestellungen, plz) 
	VALUES ('Juergen', 'Mustermann', 0, 52341);
	\end{lstlisting}

	Innerhalb der ersten Klammern geben wir die Spalten ein, die wir befüllen möchten. Die zweite Klammer enthält die tatsächlichen Werte, die wir einfügen möchten. Eine Kundennummer fügen wir nicht hinzu, da wir davon ausgehen, dass unsere Tabelle so konfiguriert ist, dass sie automatisch neue Primärschlüssel hinzufügt. Wichtig ist, dass wir sicherstellen, dass es für unsere PLZ bereits einen Eintrag in der "Orte"-Tabelle gibt.

	\subsection{DELETE FROM}
	Mit dem DELETE FROm-Statement können wir Einträge aus unserer Tabelle entfernen:

	\begin{lstlisting}[language=SQL, caption=Wir entfernen alle Jürgens aus unserer Kundentabelle]
	DELETE FROM kunden WHERE vorname = 'Juergen';
	\end{lstlisting}

	Für DELETE FROM können die gleichen WHERE-Klauseln verwendet werden, die wir schon für SELECT erläutert haben.

	\subsection{Der DatabaseConnector}
Um durch ein Java-Programm auf eine Datenbank zugreifen zu können, benutzen wir im Schulrahmen die Klassen "DatabaseConnector" und "QueryResult". Die Dokumentation dieser Klassen findet ihr \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp\_SII/if/Dokumentation\_ZA-IF\_GK-LK\_ab\_2018\_2021\_12\_22.pdf#page=31}{\underline{hier für den DatabaseConnector}} und \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp\_SII/if/Dokumentation\_ZA-IF\_GK-LK\_ab\_2018\_2021\_12\_22.pdf#page=32}{\underline{hier für das QueryResult}}

	\subsubsection{Beispiel}
	Ein Beispielprogramm zur Interaktion mit einer Datenbank in Java könnte wie folgt aussehen:

	\begin{lstlisting}[language=Java]
	public class Beispiel {
		DatabaseConnector connector;

		public Beispiel() {
			this.connector = DatabaseConnector(
				pIp="localhost",
				pPort="5432",
				pDatabase="kundendb",
				pUsername="admin",
				pPassword="admin"
			);
		}

		public void neuerKunde(String pVorname, String pNachname, int pPlz) {
			if (!checkPlzExists(pPlz)) {
				throw new SQLException("PLZ existiert nicht; bitte hinzufuegen");
			}

			this.connector.executeStatement(
				"INSERT INTO kunden (vorname, nachname, bestellungen, plz) \
				VALUES ('"+ pVorname +"', '"+ pNachname +"', 0, "+ pPlz +");"
			);
		}

		public String[] holAlleKunden() {
			this.connector.executeStatement("SELECT * FROM kunden;");
		
			// Prueft auf Fehler
			String error = this.connector.getErrorMessage();
			if (error != null) {
				throw new SQLException("Irgendwas ging schief: " + error);
			}

			QueryResult result = this.connector.getCurrentQueryResult();
			String[][] data = result.getData();
			String[] out = new String[data.length];
		
			for (int i = 0; i< data.length; i++) {
				out[i] = data[i][0];
			}
			return out;
		}

		public void fuegeOrtHinzu(int pPlz, String pName) {
			if (checkPlzExists(pPlz)) {
				throw new SQLException("PLZ existiert bereits");
			}
			this.connector.executeStatement(
				"INSERT INTO orte (plz, name) \
				VALUES "+ pPlz +"'"+ pName +"');"
			);
		}

		public boolean checkPlzExists(int plz) {
			this.connector.executeStatement("SELECT plz FROM orte WHERE plz = " + String.valueOf(plz) + ";");

			if (this.connector.getErrorMessage() != null) {
				throw new SQLException("Irgendwas ging schief");
			}
			return this.connector.getCurrentQueryResult() != null; // Wenn ein Eintrag gefunden wurde, return wir true
		}
	}
	\end{lstlisting}


	\section{Nicht-Lineare Datenstrukturen}

	\section{Formale Sprachen, Grammatiken und Automaten}
	
	\subsection{Formale Sprachen}
	
	\subsubsection{Definition}
	
	\begin{itemize}
		\item Menge von Symbolanordnungen
		\item vorgegebene Regeln
		\item Syntax: erlaubte Ausdrücke
		\item Semantik: Bedeutung von Ausdrücken (in formalen Sprachen nicht definiert)
	\end{itemize}
	
	\subsubsection{Alphabet}
	
	\begin{itemize}
		\item Menge zulässiger Zeichen für eine Sprache
		\item Bezeichnung: $\Sigma$
	\end{itemize}
	
	\subsubsection{Wort}
	
	\begin{itemize}
		\item beliebige endliche Aneinanderreihung von Zeichen des Alphabets
		\item leeres Wort ($\epsilon$): Wort ohne Buchstaben
		\item Menge aller Worte aus dem Alphabet $\Sigma$ inklusive $\epsilon$: $\Sigma$*
		\item $\Sigma$* kann Worte mit unendlicher Länge enthalten und enthält daher unendlich viele Worte
	\end{itemize}
	
	\subsubsection{Syntaxdiagramme}
	
	\begin{itemize}
		\item mehrere Symbole hintereinander
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Sequence}
			\caption{In den Rechtecken stehen Zeichen des Alphabets. Diese werden nacheinander angefügt, um ein Wort zu bilden. Diese Kette kann beliebig lang sein.}
		\end{figure}	
		\item Iteration (0 - $\infty$)
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Iteration_0-n}
			\caption{In dem Rechteck steht ein Zeichen des Alphabets. Dieses kann beliebig oft aneinandergereiht werden, muss aber nicht verwendet werden.}
		\end{figure}	
		\item Iteration (1 - $\infty$)
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Iteration_1-n}
			\caption{In dem Rechteck steht ein Zeichen des Alphabets. Dieses muss mindestens einmal, kann aber auch beliebig oft verwendet werden.}
		\end{figure}	
		\item Auswahl
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Selection}
			\caption{In den Rechtecken stehen Zeichen des Alphabets. Von diesen muss genau eines an das entstehende Wort angehängt werden.}
		\end{figure}	
		\item Option
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Option}
			\caption{In dem Rechteck steht ein Zeichen des Alphabets. Dieses kann genau einmal oder gar nicht an das entstehende Wort angehängt werden.}
		\end{figure}	
		\item Bezug auf andere Syntaxdiagramme
		\begin{figure}[H]
			\centering
			\includesvg[width=15.0cm]{Syntaxdiagramm_in_Syntaxdiagramm_1}
			\caption{Dies ist ein Beispiel für ein Syntaxdiagramm. Mit dem von links kommenden "Anfangspfeil" kann ein Syntaxdiagramm benannt werden.}
		\end{figure}	
		\begin{figure}[H]
			\centering
			\includesvg[width=15.0cm]{Syntaxdiagramm_in_Syntaxdiagramm_2}
			\caption{In den Rechtecken können neben Zeichen des Alphabets auch Namen anderer Syntaxdiagramme stehen. Dann wird statt ein Zeichen an das entstehende Wort anzuhängen dieses Syntaxdiagramm ausgeführt.}
		\end{figure}	
	\end{itemize}
	
	\subsection{Grammatiken}
	
	\begin{itemize}
		\item eine Grammatik erzeugt (genau) eine Sprache
		\item mehrere Grammatiken können die selbe Sprache erzeugen
		\item Grammatik $G = (N, \Sigma, S, P)$
		\item $N$: Menge der Nichtterminalsymbole ("Variablen")
		\item $\Sigma$: Menge der Terminalsymbole / Alphabet
		\item $S$: Startsymbol mit $S \in N$
		\item $P$: Menge der Produktionsregeln \\
		Beispiele:
		\begin{itemize}
			\item A $\rightarrow$ B
			\item A $\rightarrow$ B, B $\rightarrow$ A
			\item A $\rightarrow$ 0 $\mid$ 1
			\item A $\rightarrow$ 0B $\mid$ 100B $\mid$ $\epsilon$
		\end{itemize}
		\item $N \cap \Sigma = \varnothing$ (nichts ist gleichzeitig Terminal- und Nichtterminalsymbol)
	\end{itemize}
	
	\subsubsection{Reguläre Grammatiken}
	
	Man unterscheidet zwischen rechts- und linksregulären Grammatiken. Ist dies nicht genauer spezifiziert, sind meist rechtsreguläre Grammatiken gemeint. Eine (rechts-) reguläre Grammatik $G = (N, \Sigma, S, P)$ hat in der Menge der Produktionsregeln $P$ nur Produktionsregeln der Form:
	\begin{itemize}
		\item $A = \sigma B$
		\item $A = \sigma$
	\end{itemize}
	Dabei gilt: 
	\begin{itemize}
		\item $A, B \in N$
		\item $\sigma \in \Sigma$
		\item $A = B$ ist erlaubt
	\end{itemize}
	Bei rechtsregulären Grammatiken werden also Worte nur nach rechts erweitert. Entsprechend werden bei linksregulären Grammatiken Worte nur nach links erweitert ($B \sigma$ statt $\sigma B$). Eine Sprache, die durch mindestens eine reguläre Grammatik erzeugt werden kann, nennt man reguläre Sprache.
	
	\subsection{Automaten}
	
	\subsubsection{Deterministische endliche Automaten (DEA)}
	
	$A = (Q, q_0, \Sigma, F, \delta)$
	\begin{itemize}
		\item $Q$: endliche Menge von Zuständen
		\item $q_0$: Startzustand mit $q_0 \in Q$
		\item $\Sigma$: endliches Eingabealphabet
		\item $F$: Menge der Endzustände mit $F \subseteq Q$
		\item $\delta$: Übergangsfunktion mit $\delta: Q \times \Sigma \rightarrow Q$ \\
		$\implies$ ordnet jedem Paar $q \in Q$, $\sigma \in \Sigma$ einen eindeutigen Folgezustand $\delta(q,\sigma) = q'$ zu
	\end{itemize}
	
	\subsubsection{Nichtdeterministische endliche Automaten (NEA)}
	
	$A = (Q, q_0, \Sigma, F, \delta)$
	\begin{itemize}
		\item $Q$: endliche Menge von Zuständen
		\item $q_0$: Startzustand mit $q_0 \in Q$
		\item $\Sigma$: endliches Eingabealphabet
		\item $F$: Menge der Endzustände mit $F \subseteq Q$
		\item $\delta$: Übergangsrelation mit $\delta: Q \times \Sigma \rightarrow Q^n$ \\
		$\implies$ ordnet jedem Paar $q \in Q$, $\sigma \in \Sigma$ einen eindeutigen Folgezustand $\delta(q,\sigma) \subseteq Q$ zu
	\end{itemize}
	
	\subsubsection{Visualisierung}
	
	\begin{figure}[H]
		\centering
		\includesvg[width=15.0cm]{Automats_Visualisation_Example}
		\caption{Die Kreise symbolisieren Zustände. In ihnen stehen Bezeichnungen. Der Startzustand wird durch ein Dreieck gekennzeichnet. Der  Endzustand / die Endzustände werden durch einen doppelten Kreis gekennzeichnet. Start- und Endzustand können, müssen aber nicht identisch sein. Die Pfeile symbolisieren Übergänge. An ihnen stehen Zeichen des Eingabealphabets. Sie können von einem Zustand auf einen anderen oder den diesen selbst zeigen. Gehen mehrere Pfeile mit dem selben Zeichen des Alphabets von einem Zustand ab, handelt es sich um einen NDE, ansonsten um einen DEA.}
	\end{figure}	
		
	\subsubsection{Zustandstabelle}
		
	Automaten lassen sich auch in Form einer Zustandstabelle darstellen. In diesen stehen de Zeilen für die einzelnen Zustände und die Spalten für die Zeichen des Eingabealphabets. In den Zellen steht der damit jeweils erreichte Folgezustand bzw. die Menge der hiermit zu erreichenden Folgezustände. Auch der Fehlerzustand kann hier aufgeführt werden.\\
	Beispiel:
		
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
 			\hline
  			& Zustand1 & Zustand2 & $\ldots$ \\ 
  			\hline
 			Zeichen1 & Zustand2 & \{Zustand1, Zustand2\} & $\ldots$ \\ 
			\hline
 			Zeichen2 & F & Zustand2 & $\ldots$ \\ 
 			\hline
 			F & F & F & $\ldots$ \\
 			\hline
 			$\ldots$ & $\ldots$ & $\ldots$ & $\ldots$ \\
 			\hline
		\end{tabular}
	\end{center}
		
	\subsubsection{Automaten und reguläre Grammatiken}
		
	\paragraph{Zentrale Erkenntnisse}
	\begin{itemize}
		\item zu jedem endlichen Automaten gibt es eine reguläre Grammatik, die exakt die von dem Automaten erkannte Sprache erzeugt
		\item daher ist jede formale Sprache, die von einem endlichen Automaten erkannt wird, eine reguläre Sprache
		\item reguläre Grammatiken und endliche Automaten lassen sich in einander umwandeln
	\end{itemize}
		
	\paragraph{Automat $\rightarrow$ reguläre Grammatik}
	\begin{itemize}
		\item die Zustände des Automaten werden zu Nichtterminalsymbolen der Grammatik
		\item die Zeichen des Eingabealphabets des Automaten werden zu Zeichen des Alphabets bzw. Terminalsymbole der Grammatik
		\item der Startzustand des Automaten wird zum Startsymbol der Grammatik
		\item die Produktionsregeln der Grammatik können aus dem visualisierten Automaten wiefolgt abgeleitet werden: 
		\begin{figure}[H]
			\centering
			\includesvg[width=15.0cm]{Automats_Example}
			\caption{Dies ist ein Beispiel für einen Automaten, das im Folgenden die Erklärung verdeutlichen soll.}
		\end{figure}	
		\begin{itemize}
			\item kann von einem Zustand aus in den Endzustand übergegangen werden, wird der Produktionsregel für das entsprechende Nichtterminalsymbol die Umwandlung in das Terminalsymbol hinzugefügt, das dem Zeichen des Eingabealphabets entspricht, welches verwendet wird, um den Endzustand zu erreichen \\
			Beispiel: $A \rightarrow 1$, da von A in den Endzustand B übergegangen werden kann, wenn die 1 gewählt wird.
			\item für jeden Übergang des Automaten wird der Grammatik eine Produktionsregel hinzugefügt, bei der auf der linken Seite das Nichtterminalsymbol steht, das dem Zustand am stumpfen Ende des Pfeils entspricht und auf der rechten Seite zuerst das Terminalsymbol / Symbol des Eingabealphabets, das am Pfeil steht und danach das Nichtterminalsymbol, das dem Zustand entspricht, der an der Spitze des Pfeils steht \\
			Beispiel: $A \rightarrow 0A$ und $A \rightarrow 1B$
		\end{itemize}
		Insgesamt ergibt sich für dieses Beispiel: \\
		$A \rightarrow 0A \mid 1B \mid 1$ \\
		$B \rightarrow 0A \mid 1B \mid 1$
	\end{itemize}

	\section{Datenschutz}

\end{document}
