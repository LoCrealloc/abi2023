\documentclass{article}

\usepackage{graphicx}
\usepackage{amsfonts,amsmath,amssymb,amsthm}
\usepackage{svg}
\usepackage{float}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[inner=3cm, outer=3cm, top=2cm, bottom=2.5cm]{geometry}

\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle}

\hbadness=10001
\hfuzz=4pt
\vfuzz=4pt

\title{Informatik}
\date{Q2 2022/2023}
\author{Paul SK \& Sophie}

\begin{document}
	\pagenumbering{gobble}
	\maketitle
	\newpage

	\pagenumbering{arabic}

	\section{Allgemeines}
	\subsection{Dokumentationen}
	Eine vollständige Dokumentation sämtlicher Abiturrelevanter Klassen kann \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp\_SII/if/Dokumentation\_ZA-IF\_GK-LK\_ab\_2018\_2021\_12\_22.pdf}{\underline{hier gefunden werden}}.

	\section{OOP mit Java}
	\subsection{Java-Grundwissen}
	\subsubsection{Variablen}
	Variablen sind Werteplatzhalter. In Java haben Variablen einen festen Datentypen; die wichtigsten Datentypen sind 

	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | c | l | }
			\hline
			\textbf{Datentyp} 	& \textbf{in Java} 	& \textbf{Funktion} \\
			\hline
			\hline
			\textbf{Integer}	& int				& Ganze Zahlen mit 4 Byte ($\pm 2,147,483,647$) \\
			\textbf{Long}		& long 				& Ganze Zahlen mit 8 Byte ($\pm 9,223,372,036,854,775,807$) \\
			\textbf{Double} 	& double			& Kommazahlen mit 8 Byte (bis ~ 15 Stellen) \\
			\textbf{Float} 		& float 			& Kommazahlen mit 4 Byte (bis ~ 7 Stellen) \\
			\textbf{Boolean}	& boolean			& Wahrheitswert (\textit{true/false}) \\
			\textbf{Character} 	& char 				& Einzelner Buchstabe / ASCII-Wert \\
			\textbf{String} 	& String 			& Zeichenkette; mehrere Buchstaben \\
			\hline
		\end{tabular}
	\end{center}

	Eine Variable wird in Java zunächst deklariert

	\begin{lstlisting}[language=Java, caption=Deklarierung einer Variable in Java]
		int x;
	\end{lstlisting}

	und anschließend initialisiert

	\begin{lstlisting}[language=Java, caption=Initialisierung einer Variable in Java]
		x = 42;
	\end{lstlisting}

	Diese zwei Schritte können auch in einem Schritt zusammengefasst werden

	\begin{lstlisting}[language=Java, caption=Deklarierung und Initialisierung einer Variable]
		int y = 42;
	\end{lstlisting}

	\paragraph{Type conversion}
	Einen String kann man mithilfe der \textit{Integer.parseInt()}-Methode in einen Integer konvertieren.

	\begin{lstlisting}[language=Java, caption=String-zu-Integer-Konvertierung]
		int x = Integer.parseInt("1");
	\end{lstlisting}

	Einen Integer kann man mit der \textit{String.valueOf()}-Methode in einen String konvertieren.

	\begin{lstlisting}[language=Java, caption=Integer-zu-String-Konvertierung]
		String x = String.valueOf(1);
	\end{lstlisting}

	\subsubsection{Arrays}
	Wenn man mehrere Werte auf einmal speichern möchte, so kann man dies in einem Array tun. Hierfür gibt man bei der Deklaration einer Variable neben dem Datentyp auch die (feste) Länge des Arrays an
	
	\begin{lstlisting}[language=Java, caption=Deklarierung eines Integer-Arrays mit 5 Feldern] 
		int[] a = new int[5];
	\end{lstlisting}

	Auf die einzelnen Stellen eines Arrays kann über einen Index zugegriffen werden

	\begin{lstlisting}[language=Java, caption=Zugriff auf ein Array] 
		int b = a[1];
		a[3] = 12;
	\end{lstlisting}

	Wenn man die Länge eines Arrays erhalten möchte, so kann man mit dem \textit{.length}-Attribut auf diese Zugreifen:

	\begin{lstlisting}[language=Java, caption=Zugriff auf die Array-Länge] 
		int c = a.length;
	\end{lstlisting}

	Das Array hat in Java noch viele weitere Attribute und Methoden, auf die hier nicht weiter eingegangen werden wird.

	\subsubsection{Schleifen}
	Um einzelne Codeabschnitte zu wiederholen, können Schleifen genutzt werden.

	\paragraph{For-Schleife}
	Eine for-Schleife besteht aus 5 Teilen: dem Aufruf der Schleife (\textit{for}), der Deklaration und Initialisierung der Zählvariable (\textit{int i = 0;}), der Abbruchbedingung (\textit{i < 42;}), dem Zähler (\textit{i += 1}) und dem Schleifenkörper (\textit{System.out.println(i);}).


	\begin{lstlisting}[language=Java, caption=beispiel für eine for-Schleife] 
		for (int  i = 0; i < 42; i += 1) {
			System.out.println(i);
		}
	\end{lstlisting}

	Eine for-Schleife ist insbesondere praktisch, um durch lineare Datenstrukturen wie ein Array zu iterieren:

	\begin{lstlisting}[language=Java, caption=Iteration durch ein Array mit einer for-Schleife] 
		int[] arr = {2, 3, 5, 7, 11};

		for (int  i = 0; i < arr.length; i++) {
			System.out.println(arr[i]);
		}
	\end{lstlisting}

	\subparagraph{For-each-Schleife}

	Für die Iteration durch ein Array gibt es in Java allerdings auch die für diesen Fall besser geeignete \textit{for-each-Schleife}, bei der es keine Zählvariable gibt, sondern lediglich eine Schleifenvariable, die in jedem Durchlauf einen Wert aus dem Array beinhaltet:

	\begin{lstlisting}[language=Java, caption=Iteration durch ein Array mit einer for-each-Schleife] 
		int[] arr = {2, 3, 5, 7, 11};

		for (int x : arr) {
			System.out.println(x);
		}	
	\end{lstlisting}

	\paragraph{While-Schleife}
	Wenn man keine feste Anzahl an Durchläufen benötigt, benutzt man die while-Schleife, die aus 3 teilen besteht: dem Schleifenaufruf (\textit{while}), der Abbruchbedingung (\textit{x > 0}) und dem Schleifenkörper (\textit{x++}):


	\begin{lstlisting}[language=Java, caption=Eine einfache while-Schleife]
		int x = 100;
		
		while (x > 100) {
			x++;
		}
	\end{lstlisting}

	\subsubsection{if-Abfragen}
	Programme müssen häufig abhängig von bestimmten Bedingungen entscheidungen treffen. Für diesen zweck gibt es in Java die if-Abfrage. Diese besteht aus dem Aufruf (\textit{if}), der Bedingung (\textit{x > 12}) und dem Körper (\textit{System.out.println("Ist größer");}). Nur, wenn die Bedingung der Abfrage zutrifft, wird der Code im Körper ausgeführt.

	\begin{lstlisting}[language=Java, caption=Eine einfache if-Abfrage]
		int x = 40;

		if (x > 12) {
			System.out.println("Ist groesser");
		}
	\end{lstlisting}

	Wenn man weitere Abfragen oder einen Codeabschnitt, der ausgefürt wird, wenn keine Bedingung zutrifft, benötigt, so nutzt man die \textit{else} bzw. \textit{if-else}-Bedingungen.

	\begin{lstlisting}[language=Java, caption=Eine einfache if-else-Kette]
		int x = 100;

		if (x > 100) {
			System.out.println("Groesser 100")
		} else if (x == 100) {
			System.out.println("Gleich 100")
		} else {
			System.out.println("Kleiner 100")
		}
	\end{lstlisting}

	\subsection{Objektorientierte Programmierung}
	Java ist eine objektorientierte Programmiersprache. Das bedeutet, das jeglicher Code Teil einer größeren Klassenstruktur ist, die diesen Code verwaltet.

	\subsubsection{Klassen und Objekte}
	Eine Klasse abstrahiert in der OOP Teile oder Zusammenhänge der realen Welt. Beispielsweise kann man mit einer Klasse ein Auto beschreiben: die Klasse "Auto" ist dann quasi die Repräsentation eines Autos in einem Programm, damit der Computer mit diesem arbeiten kann. Objekte sind dann die tatsächlichen Instanzen, die ein Programm letztendlich nutzt. EIne Klasse "Auto" kann dann beispielsweise in einem Objekt "Tesla Model S" instanziiert werden

	\paragraph{Attribute}
	Um eine Abstraktion zu beschreiben, können Klassen Attribute haben. Diese sind klassenzugehörige Variablen, mit denen Eigenschaften einer Klasse beschrieben werden. In einem Objekt bekommen diese Atttribute richtige Werte. Ein Auto kann beispielsweise die Attribute "Farbe" oder "Preis" haben.

	\subparagraph{Datentyp}
	Attribute sind Variablen. Folcglich müssen auch sie mit einem Datentypen deklariert werden.

	\subparagraph{Sichtbarkeit}
	Ein Attribut hat auch eine Sichtbarkeit, die beschreibt, wie andere Klassen mit diesem Attribut interagieren können

	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | l | }
			\hline
			\textbf{Sichtbarkeit} 	& \textbf{Arbeitsweise} \\
			\hline
			\hline
			\textbf{public} 		& Jede Klasse kann auf dieses Attribut zugreifen \\
			\textbf{protected} 		& Die eigene Klasse und Unterklassen können auf dieses Attribut zugreifen \\
			\textbf{private} 		& Nur die eigene Klasse kann auf dieses Attribut zugreifen \\
			\hline
		\end{tabular}
	\end{center}

	\paragraph{Methoden}
	Neben den Eigenschaften kann eine Klasse auch sogenannte \textit{Methoden} haben. Diese Methoden dienen dazu, Aktionen einer Klasse darzustellen. Ein Auto kann in diesem Beispiel etwa die Methoden "fahren", "lichtEinschalten" und Ähnliche haben.

	\subparagraph{Parameter}
	Methoden können auch abhängig von bestimmten Eingabeparamtern operieren. Diese Parameter werden im Methodenkopf deklariert und beim Methodenaufruf übergeben.

	\subparagraph{Rückgabewerte}
	Eine Methode kann auch einen Wert zurückgeben. Damit eine Methode etwas zurückgeben darf, muss der Rückgabetyp im Methodenkopf deklariert werden.

	\subparagraph{Sichtbarkeit}
	Genau wie ein Attribut kann auch eine methode einen der Sichtbarkeitstypen \textit{public, protected oder private} haben. Dieser wird ebenfalls im Methodenkopf angegeben.

	\begin{lstlisting}[language=Java, caption=Ein Beispiel für einen Methodenkopf]
		private int addiere(int a, int b) 
	\end{lstlisting}

	\subsubsection{Konstruktoren}
	Ein Konstruktor ist eine Art Methode, die bei der Initialisierung eines Objektes aufgerufen wird. Diesem Konstruktor können auch Parameter übergeben werden, die etwa den Anfangzustand eines Objektes festlegen können. Ein Konstruktor hat keinen Rückgabewert, ist immer \textit{public} und hat die gleiche Bezeichnung wie die Klasse.

	\begin{lstlisting}[language=Java, caption=Ein Beispiel für eine Klasse mit Konstruktor]
		class X {
			private int c

			public X(int a, int b) {
				this.c = a + b;
			}
		}
	\end{lstlisting}

	\subsubsection{Überladung}
	In Java kann eine Methode (oder ein Konstruktor) mehrfach mit unterschiedlichen Methodenköpfen deklariert werden. Der compiler bzw die runtime entscheidet dann abhängig von den übergebenen Parametern, welche Methode eigentlich aufgerufen werden soll.

	\begin{lstlisting}[language=Java, caption=Ein Beispiel für Überladung]
		class X {
			private int z;

			public void setZ() {
				z = 0;
			}

			public void setZ(int pZ) {
				z = pZ;
			}
		}
	\end{lstlisting}

	\subsubsection{Vererbung}
	Eine Unterklasse kann von einer anderen Oberklasse erben. Dabei übernimmt die Unterklasse die Attribute und Methoden der Oberklasse. Dieser Mechanismus kann genutzt werden, um Code einzusparen. Eine Vererbung wird im Klassenkopf über das \textit{extends}-Keyword angegeben.

	\begin{lstlisting}[language=Java, caption=Vererbung im Klassenkopf]
		class X extends Y {}
	\end{lstlisting}

	\paragraph{Polymorphie}
	Die Unterklasse übernimmt nach einer Vererbung auch den Datentyp ihrer Oberklasse.

	\newpage

	\subsection{Implementationsdiagramme in UML}
	Um Objektorientierte Projekte zu modellieren, wird die Modellierungssprache UML verwendet.

	\subsubsection{Klassen}
	Klassen werden in einem dreigeteilten Rechteck dargestellt. Dieses Rechteck enthält im ersten Block den Klassennamen, im zweiten Block die Klassenattribute und im dritten Block die Klassenmethoden.

	\paragraph{Attribute}
	Die Attribute werden über ihre Sichtbarkeit, ihren Namen und ihren Datentypen beschrieben. Ein privates Attribut "x" vom Datentyp "Integer" könnte folgendermaßen aufgeschrieben werden:

	\begin{center}
		- x: int
	\end{center}

	\paragraph{Methoden}
	Klassenmethoden werden über ihre Sichtbarkeit, ihren Namen, ihre Parameter (inklusive Datentyp) und ihren Rückgabewert beschrieben. Eine öffentliche Methode "addiere", die die Summe zweier Integer-Parameter zurückgibt, könnte wie folgt modelliert werden:

	\begin{center}
		+ addiere(a: int, b: int): int
	\end{center}

	\subparagraph{Konstruktoren}
	Auch, wenn ein konstruktor keine Methode im eigentlichen Sinne ist, wird dieser wie eine Methode modelliert. Der einzige Unterschied besteht darin, dass er immer öffentlich (public) sein muss, den Namen der Klasse trägt und keinen Rückgabewert haben darf. Ein Konstruktor für die Klasse "Speicher", der einen double übergeben bekommt, könnte so modelliert werden:

	\begin{center}
		+ Speicher(x: double)
	\end{center}

	\begin{figure}[h!]
		\centering
		\includesvg[inkscapelatex=false,width=5cm]{uml_basic}
		\caption{Ein Beispiel für die Modellierung einer einfachen Klasse}
	\end{figure}

	\subsubsection{Vererbung}
	Um Vererbung zu modellieren, wird in UML ein Pfeil von der Unterklasse zur Oberklasse gezeichnet. Die Pfeilspitze ist abgeschlossen, aber nicht ausgefüllt.

	\begin{figure}[h!]
		\centering
		\includesvg[inkscapelatex=false,width=9cm]{uml_inheritance}
		\caption{Ein Beispiel für die Modellierung von Vererbung}
	\end{figure}

	\subsubsection{Assoziation}
	Eine Assoziation beschreibt die Beziehung zwischen zwei Klassen. Eine Assoziation wird, ähnlich wie bei der Vererbung, durch einen Pfeil gekennzeichnet. Dieser ist bei Assoziationen allerdings nicht geschlossen, sondern am Ende offen. Attribute, die Instanzen/Objekte einer anderen Klasse sind, werden auch durch eine Assoziation gekennzeichnet. Auf dem Assoziationspfeil wird die Sichtbarkeit des Attributes, sein Name und seine Menge angegeben.

	\begin{figure}[h!]
		\centering
		\includesvg[inkscapelatex=false,width=9cm]{uml_associations}
		\caption{Ein Beispiel für die Modellierung einer Assoziation}
	\end{figure}

	\subsubsection{Datentypen bei generischen Klassen}
	Wenn man generische Klassen in seinem Projekt verwendet, ist es häufig notwendig, den in diesen Klassen verwendeten Datentypen anzugeben. Dies wird über ein kleines Hinweisfeld realisiert, das an die Klasse angefügt wird. Die generischen Klassen, die im Unterricht behandelt wurden (Queue/List/...) müssen in der Regel bei der Benutzung nicht komplett modelliert werden. 

	\begin{figure}[h!]
		\centering
		\includesvg[inkscapelatex=false,width=9cm]{uml_generics}
		\caption{Ein Beispiel für die Modellierung von generischen Klassen; im Beispiel die Klasse List aus dem Unterricht}
	\end{figure}

	\subsubsection{Interfaces}
	Wenn man ein Interface implementieren möchte, zeichnet man von der implementierenden Klasse einen gestrichelten Pfeil mit geschlossener Spitze zu der Modellierung des Interfaces, in welchem die implementierende Klasse auch nochmal als generischer Typ angegeben wird. Die Vorgehensweise ist also ähnlich wie bei der Vererbung.

	\begin{figure}[h!]
		\centering
		\includesvg[inkscapelatex=false,width=9cm]{uml_interface}
		\caption{Ein Beispiel für die Modellierung eines Interfaces und einer implementierenden Klasse}
	\end{figure}
	

	\section{Lineare Datenstrukturen}

	\section{Algorithmen}
	\subsection{Komplexität}
	Um die Effizienz eines Algorithmus zu bestimmen, verwenden Informatiker den Begriff "Komplexität". Die Effizienz kann mithilfe dieses Begriffes unabhängig von Programmiersprache, Compiler, dem ausführenden Computer und Ähnlichem verglichen werden.
	\subsubsection{Big-O-Notation}
	Die bekannteste Methode zur Beschreibung der Komplexität ist die sogenannte \textit{Big-O-Notation}. Die Big-O-Notation gibt an, welche Komplexität ein Algorithmus \textit{höchstens} hat.
	
	\paragraph{Paragraph}
	Die Funktion $T(n) \in O(g(n))$, wenn es positive Konstanten $c$ und $n_0$ gibt, so dass gilt: 

	\begin{align*}
		T(n) \leq c \cdot g(n) \\
		n \geq n_0
	\end{align*}

	\subparagraph{Wie schnell kann ein Algorithmus sein?}
	Zum sortieren einer Folge von n Keys mit einem allgemeinen Sortierverfahren sind im worst case sowie im average case mindestens \textit{$O(n \cdot \log{n})$} Vergleichsoperationen zwischen zwei Schlüsseln erforderlich.

	\subsection{Sortieralgorithmen}
	\subsubsection{Bubblesort}
	\paragraph{Allgemeine Beschreibung}
	Der vermutlich einfachste in-place Sortieralgorithmus ist der Bubblesort. Bei diesem Verfahren lässt der Algorithmus Werte innerhalb einer Werteliste, beispielsweise eines Arrays, solange "aufsteigen", bis sie an der richtigen Stelle angelangt sind. Da diese Vorgehensweise an das Aufsteigen von Luftblasen erinnert, ist der Algorithmus nach diesem Vergleich benannt.

	\paragraph{Codebeispiele}
	\begin{lstlisting}[caption=Der Bubblesort-Algorithmus in einfachem Pseudocode]
	method bubblesort(A) {
		l = A.length

		for i = 1 to l {
			for j = 0 to l - i {
				if A[j] groesser A[j + 1] {
					swap(A[j], A[j + 1])
				}
			}
		}
	}
	\end{lstlisting}

	Wie aus dem Pseudocode erkennbar ist, besteht der Pseudocode aus zwei Schleifen: die äußere Schleife arbeitet die Werteliste ab. während die innere Liste den aktuellen Wert beim Anfang des Arrays beginnend mit dem nächsten vergleicht und diese Werte, falls notwendig, vertauscht, bis die innere Schleife beim in der äußeren Schleife aktuellen Wert angelangt ist. Zum Schluss ist das Array fertig sortiert.

	
	\begin{lstlisting}[language=Java, caption=Der Bubblesort-Algorithmus in Java]
	public static void bubblesort(int[] A) {
		int l = A.length;

		for (int i = 1; i < l; i++) {
			for (int j = 0; j < l - i; j++) {
				if (A[j] > A[j + 1]) {
					int c = A[j];
					A[j] = A[j + 1];
					A[j + 1] = c;
				}
			}
		}
	}
	\end{lstlisting}

	\paragraph{Komplexität}
	Aufgrund seiner Funktionsweise mit den zwei verschachtelten Schleifen läuft der Bubblesort in jedem Fall (sowohl best als auch worst case) in \textbf{$O(n^2)$}, was ihn zu einem äußerst ineffizienten Sortieralgorithmus macht.

	\subsubsection{Insertionsort}
	\paragraph{Allgemeine Beschreibung}
	Ein weiterer einfacher Sortieralgorithmus ist der Insertionsort. Bei diesem Verfahren wird die Werteliste in zwei Teile unterteilt: den sortierten Teil und den unsortierten Teil. Der Algorithmus iteriert durch den unsortierten Teil und fügt jeden Wert an der richtigen Stelle in den sortierten Teil ein, indem er die Werte im sortierten Teil nach rechts verschiebt, um Platz für den einzufügenden Wert zu schaffen. Dieser Vorgang wird wiederholt, bis der gesamte unsortierte Teil in den sortierten Teil eingefügt wurde und die Liste vollständig sortiert ist.

	\paragraph{Codebeispiele}
	\begin{lstlisting}[caption=Der Insertionsort-Algorithmus in einfachem Pseudocode]
	method insertionsort(A) {
		l = A.length

		for i = 1 to l - 1 {
			key = A[i]
			j = i - 1

			while j groesser gleich 0 and A[j] groesser key {
				A[j + 1] = A[j]
				j = j - 1
			}

			A[j + 1] = key
		}
	}
	\end{lstlisting}

	Wie aus dem Pseudocode ersichtlich ist, verwendet der Insertionsort eine Schleife, um durch den unsortierten Teil der Werteliste zu iterieren. Innerhalb dieser Schleife wird der aktuelle Wert in der Variablen "key" gespeichert und mit den Werten im sortierten Teil der Liste verglichen. Solange der aktuelle Wert kleiner ist als der verglichene Wert im sortierten Teil, werden die Werte im sortierten Teil nach rechts verschoben, um Platz für den einzufügenden Wert zu schaffen. Am Ende wird der aktuelle Wert an der richtigen Stelle in den sortierten Teil eingefügt.


	\begin{lstlisting}[language=Java, caption=Der Insertionsort-Algorithmus in Java]
	public static void insertionsort(int[] A) {
		int l = A.length;

		for (int i = 1; i < l; i++) {
			int key = A[i];
			int j = i - 1;

			while (j >= 0 && A[j] > key) {
				A[j + 1] = A[j];
				j = j - 1;
			}

			A[j + 1] = key;
		}
	}
	\end{lstlisting}

	\paragraph{Komplexität}
	Die Zeitkomplexität des Insertionsort-Algorithmus beträgt im Durchschnitt \textbf{$O(n^2)$}, da im worst case-Fall jeder Wert im unsortierten Teil mit jedem Wert im sortierten Teil verglichen werden muss. Im besten Fall, wenn die Liste bereits teilweise sortiert ist, kann die Komplexität jedoch auf \textbf{$O(n)$} reduziert werden. Der Insertionsort-Algorithmus eignet sich gut für kleine Listen oder bereits teilweise sortierte Listen, aber kann ineffizient sein für große Listen mit vielen unsortierten Elementen.


	\subsubsection{Selectionsort}
	\paragraph{Allgemeine Beschreibung}
Ein weiterer einfacher Sortieralgorithmus ist der Selectionsort. Bei diesem Verfahren wird die Werteliste in zwei Teile unterteilt: den sortierten Teil und den unsortierten Teil. Der Algorithmus sucht den kleinsten (oder größten, je nach Sortierreihenfolge) Wert im unsortierten Teil und tauscht ihn mit dem ersten Element im unsortierten Teil. Dieser Vorgang wird wiederholt, bis der gesamte unsortierte Teil in den sortierten Teil verschoben wurde und die Liste vollständig sortiert ist.

	\paragraph{Codebeispiel}
	\begin{lstlisting}[caption=Der Selectionsort-Algorithmus in einfachem Pseudocode]
	method selectionsort(A) {
		l = A.length

		for i = 0 to l - 1 {
			minIndex = i

			for j = i + 1 to l {
				if A[j] < A[minIndex] {
					minIndex = j
				}
			}

			swap(A[i], A[minIndex])
		}
	}
	\end{lstlisting}

	Wie aus dem Pseudocode ersichtlich ist, verwendet der Selectionsort zwei Schleifen. Die äußere Schleife iteriert durch den unsortierten Teil der Werteliste, während die innere Schleife den kleinsten (bzw. größten) Wert im unsortierten Teil sucht. Am Ende wird dieser Wert mit dem ersten Element im unsortierten Teil getauscht, um ihn in den sortierten Teil zu verschieben.

	\begin{lstlisting}[language=Java, caption=Der Selectionsort-Algorithmus in Java]
	public static void selectionsort(int[] A) {
		int l = A.length;

		for (int i = 0; i < l - 1; i++) {
			int minIndex = i;

			for (int j = i + 1; j < l; j++) {
				if (A[j] < A[minIndex]) {
					minIndex = j;
				}
			}

			int temp = A[i];
			A[i] = A[minIndex];
			A[minIndex] = temp;
		}
	}
	\end{lstlisting}

	\paragraph{Komplexität}
	Die Zeitkomplexität des Selectionsort-Algorithmus beträgt immer \textbf{$O(n^2)$}, da im worst case-Fall jeder Wert im unsortierten Teil mit jedem anderen Wert im unsortierten Teil verglichen werden muss, um den kleinsten (bzw. größten) Wert zu finden und zu tauschen.
	
	\subsubsection{Quicksort}
	
	\paragraph{Allgemeine Beschreibung}
	
	Ein komplexeres, aber auch schnelleres Sortierverfahren ist der Quicksort. Hier wird zuerst ein sogenanntes Pivot-Element bestimmt. Im Optimalfall ist dies der Median der Liste, da dieser aber nicht bekannt ist, wird häufig das erste, letzte oder ein zufälliges Element der Liste gewählt. Daraufhin werden alle anderen Werte anhand des Pivots vorsortiert - sind sie kleiner, werden sie links davon einsortiert, sind sie größer, kommen sie nach rechts. Somit ist das Pivot-Element an seinem richtigen Platz und alle anderen Werte in zwei Teillisten unterteilt; eine links und eine rechts vom Pivot. Mit diesen Teillisten wird nun genauso verfahren wie mit der gesamten Liste zuvor - es wird ein Pivot-Element gewählt, alle anderen Werte anhand dessen vorsortiert und somit wiederum in Teillisten aufgeteilt. Auch mit diesen wird genauso verfahren. Dies endet, wenn eine Teilliste leer ist, oder nur noch aus einem Element besteht. Gibt es nur noch solche Teillisten, ist die Liste vollständig sortiert. 
	
	\paragraph{Codebeispiel}
	\begin{lstlisting}[caption=Der Quicksort-Algorithmus in einfachem Pseudocode]
	
	method quicksort(A, left, right) {
	
		if links < rechts {
			pivotPlace = split(A, left, right)
			
			quicksort(A, links, pivotPlace - 1)
			quicksort(A, pivotPlace + 1, right)
		}
	}
	
	method split(A, left, right) {
		
		pivot = 	A[left]
		i = 	left + 1
		j = right
		
		while i < j {
			
			while i < j and A[i] <= pivot {
				i = i + 1
			}
			
			while i < j and A[j] > pivot {
				j = j - 1
			}
			
			if A[i] > A[j] {
				swap(A[i], A[j])			
			}
					
		}
		
		if A[i] < pivot {
			swap(A[i], A[left])
		}
		
		else {
			i = left		
		}
		
		return i
		
	}
	
	\end{lstlisting}
	
	Wie an dem Code zu sehen ist, wird beim Quicksort-Algorithmus ein sogenanntes Pivot-Element an seinen Platz in der Liste gesetzt und dabei die gesamte Liste in zwei Teillisten unterteilt (links Werte kleiner als das Pivot-Element; rechts größere Werte als das Pivot-Element). Diese Teillisten werden dann wiederum genauso behandelt wie die gesamte Liste im ersten Schritt, der Algorithmus arbeitet also rekursiv. Das aufteilen in zwei Teillisten funtioniert dabei wiefolgt: Ein Pivot-Element wird gewählt. Hier ist es das erste Element der Liste, es kann aber auch das letzte oder ein zufällig gewähltes Element sein. Außerdem gibt es zwei Variablen, die die Liste durchlaufen, eine von links nach rechts (i) und eine von rechts nach links (j). Trifft i auf einen Wert, der größer ist als das Pivot-Element und j auf einen, der kleiner ist, werden diese beiden Werte vertauscht. Dann laufen die Zeiger weiter. Finden sie wieder Werte, die den Kriterien für einen Tausch entsprechen, werden diese wieder getauscht. Kommt es dazu, dass beide Variablen auf das selbe Element zeigen oder sich überkreuzen, sind alle Werte gefunden, die getauscht werden müssen - alle Werte, die kleiner als das Pivot-Element sind sind auf der linken Seite der Zeiger und alle Anderen auf der Rechten. Nun muss nur noch entschieden werden, ob das Pivot-Element schon an der richtigen Stelle steht oder noch mit dem Element, auf den die Zeiger zeigen getauscht werden muss. Nun ist das Pivot-Element an der richtigen Stelle einsortiert und die Teillisten links bzw. rechts des Pivot-Elements können auf die gleiche Weise sortiert werden solange sie aus mehr als einem Element bestehen (denn ein Element ist immer sortiert). 
	
	\paragraph{Komplexität}
	
	Die Zeitkomplexität des Quicksorts unterscheidet sich zwischen seinem Worst- und seinem Best- und Average-Case. Welcher davon eintritt hängt von der Wahl des Pivot-Elements ab. Im Worst-Case wird entweder das größte oder das kleinste Element der Liste als Pivot-Element gewählt und die länge der zu sortierenden Teilliste verringert sich in jedem Schritt nur um ein Element. In diesem Fall beträgt die obere Grenze der Zeitkomplexität $O(n^2)$. Tritt dieser Fall jedoch nicht ein, also kommt es zu Average- oder Best-Case, liegt die obere Grenze der Zeitkomplexität bei $O(n \cdot \log(n))$. Zum Best-Case kommt es, wenn als Pivot-Element der Median der Liste gewählt wird und somit die Teillisten im nächsten Sortierschritt nur halb so lang wie die bisherige Liste sind. 
	
	\subsubsection{Mergesort}
	
	\paragraph{Allgemeine Beschreibung}
	
	Wie der Name schon sagt geht es beim Mergesort-Algorithmus um das Teilen und Zusammenfügen der Liste. Anders als beim Quicksort wird aber nicht beim Teilen sondern beim Zusammenfügen sortiert. Dabei funktioniert auch dieser Algorithmus rekursiv. Eine Liste wird aufgeteilt bis alle Elemente einzeln vorliegen und so trivialerweise sortiert sind. Dann wird die Liste wieder zusammengesetzt und dabei sortiert, sodass man am Ende eine sortierte Liste erhält.
	
	\paragraph{Codebeispiel}
	
	\begin{lstlisting}[caption=Der Mergesort-Algorithmus in einfachem Pseudocode]
	
	method mergesort(A) {
		if A.length <= 1 {
			return A		
		}
		
		leftList, rightList = splitHalf(A)
		leftList = mergesort(leftList)
		rightList = mergesort(rightList)
		
		return merge(leftList, rightList)
	}
	
	method merge(leftList, rightList) {
		
		while leftList.length > 0 and rightList.length > 0 {
			if leftList[0] <= rightList[0] {
				list.append(leftList[0])
				leftList.delete(leftList[0])			
			}
			else {
				list.append(rightList[0])
				rightList.delete(rightList[0])			
			}
		}
		
		while leftList.length > 0 {
			list.append(leftList[0])
			leftList.delete(leftList[0])		
		}
		
		while rightList.length > 0 {
			list.append(rightList[0])
			rightList.delete(rightList[0])
		}
		
		return list
	}
	
	\end{lstlisting}
	
	Ein Aufruf des Mergesort-Algorithmus beginnt damit, dass die übergebene Liste halbiert wird bis dies nich mehr möglich ist, also bis alle Teillisten nur noch ein Element enthalten. Ist dies geschehen, liegen nur noch sortierte Teillisten vor. Diese können nun wieder zusammengefügt werden. Hierbei wird darauf geachtet, dass die entstehende Liste sortiert wird, indem immer das erste Element aus einer der beiden Teillisten eingefügt wird, das kleiner ist. Die resultierende Liste ist selbst eine Teilliste und wird mit einer anderen Teilliste auf die gleiche Weise zusammengefügt. So entsteht nach dem letzten Schritt des Zusammenfügens eine sortierte Gesamtliste.
	
	\paragraph{Komplexität}
	
	Die Zeitkomplexität des Mergesort-Algorithmus beträgt immer $O(n \cdot \log(n))$ und ist damit im Worst-Case schneller als Quicksort. Er wird trotzdem seltener verwendet, da er kein In-Place-Verfahren ist und zusätzlichen Speicherplatz in der Größenordnung $O(n)$ benötigt.

	\section{Datenbanken}
	\subsection{Das Entity-Relationship-Modell}
	\subsubsection{Verschiedene Elemente}
	\paragraph{Entität}
	Durch eine Entität werden generelle "Dinge" abstrahiert, wie zum Beispiel Menschen, Räume, Computer usw.

	\begin{figure}[h!]
		\centering
		\includesvg[width=3.0cm]{entity}
		\caption{Eine Entität wird mit einem Rechteck dargestellt}
	\end{figure}	

	\paragraph{Attribut}
	Attribute beschreiben die Eigenschaften einer Entität. Wenn ein Attribut ein sogenannter Primärschlüssel ist, der eindeutig der Instanz einer Entität zuzuordnen ist, wird dieser unterstrichen.

	\begin{figure}[h!]
		\centering
		\includesvg[width=3.0cm]{attribute}
		\caption{Ein Attribut wird in einer Ellipse geschrieben}
	\end{figure}	

	\paragraph{Relation}
	Mithilfe von Relationen werden die Beziehungen zwischen zwei Entitäten beschrieben. Wenn ich beispielsweise sagen möchte, dass einem Menschen ein Auto gehört, stelle ich eine Relation zwischen den Entitäten "Mensch" und "Auto" her. Darüber hinaus kann eine Relation auch Attribute haben, die die Beziehung in irgendeiner Form beschreiben.
	Relationen haben immer sogenannte "Kardinalitäten". Damit wird die Menge der Beziehungen beschrieben, die zwei Entitäten haben. Davon gibt es drei Stück:

	\subparagraph{1-zu-1-Relation}
	Bei 1 zu 1 Relationen hat eine Instanz einer Entität exakt eine Beziehung zu der Instanz einer anderen Entität. Beispielsweise hat ein Mitarbeiter genau einen Firmenwagen, und jeder Firmenwagen gehört auch nur zu einem Mitarbeiter.

	\subparagraph{1-zu-n-Beziehung}
	Eine 1 zu n Beziehung beschreibt Umstände, bei denen die Instanz einer Entität mehrere Beziehungen zu verschiedenen Instanzen einer anderen Entität hat. Die Instanzen der zweiten Entität wiederum haben aber jeweils nur eine Beziehung zu der ersten Entität. Beispielsweise gehören hat die Schulklasse "7b" 20 Schüler, und jeder diese Schüler gehört zu der einen Schulklasse "7b".

	\subparagraph{n-zu-m-Beziehung}
	n zu m Relationen beschreiben Beziehungen, in denen eine Entität sich auf mehrere Instanzen anderer Entitäten beziehen kann und eine Instanz der zweiten Entität sich auch wieder auf mehrere Instanzen aus der ersten Entität bezieht. Ein Bespiel hierfür wäre eine Entität "Lehrer", deren Instanz viele Schüler unterricht (n) und Instanzen der Klasse Schüler, die von vielen verschiedenen Lehrern unterrichtet werden (m).

	Die Kardinalitäten stehen im ER-Diagramm immer von der einen Entität in Richtung einer zweiten Entität auf der Rautenseite bei der zweiten Entität.

	\begin{figure}[h!]
		\centering
		\includesvg[width=3.0cm]{relation}
		\caption{Ein Relation wird durch eine Raute repräsentiert}
	\end{figure}

	\subsubsection{Transformation}
	Bei der Transformation überführen wir ein ER-Diagramm in eine Tabellenform, die wir für eine relationale Datenbank verwenden können.
	Eine Tabelle wird wie folgt dargestellt:
	\begin{center}
		Mensch(\underline{MenschId}, Name, Geschlecht) \\
		Auto(\underline{AutoId}, Modell, Kennzeichen, $\uparrow$ MenschId)
	\end{center}
	Unterstrichene Attribute sind Primärschlüssel, Attribute mit einem nach oben zeigenden Pfeil sind Fremdschlüssel.

	\paragraph{Tranformationsregeln}
	Ein ER-Diagramm wird anhand von festen Regeln in eine Tabellenform tranformiert.

	\subparagraph{Regel 1}
	Jede Entität wird als eigene Tabelle mit Primärschlüssel dargestellt.

	\subparagraph{Regel 2}
	Jede n:m-Beziehung wird als eigene Tabelle dargestellt.

	\subparagraph{Regel 3}
	Jede 1:n- und 1:1-Beziehung mit eigenen Attributen wird wie bei Regel 2 durch eine eigene Tabelle repräsentiert.

	\subparagraph{Regel 4a}
	Jede 1:n-Beziehung ohne eigene Attribute wird so dargestellt, dass der Primärschlüssel der 1-Entität Fremdschlüssel der n-Entität wird.

	\subparagraph{Regel 4b}
	Jede 1:1-Beziehung ohne eigene Attribute wird so dargestellt, dass der Primärschlüssel der ersten Entität bei der zweiten Entität Primär- und Fremdschlüssel zugleich wird.

	\subparagraph{Regel 4c}
	Sind Regel 4a und 4b nicht anwendbar, dann wird für die Beziehung eine gesonderte Tabelle angelegt. Diese Fälle müssen aus dem Kontext abgeleitet werden.
	Beispielsweise kann eine 1:1-Relation "verheiratet mit" zwischen zwei Menschen nicht durch Regel 4b gelöst werden, da sonst eine "Heiratspflicht" bestehen würde.

	\subsection{Normalisierung}
	Wenn man einfach die Tabellen verwendet, die aus der Transformation eines ER-Diagrammes resultieren, kann es zu verschiedenen Problemen kommen. Insbesondere können sogenannte "Anomalien" auftreten:

	\paragraph{Einfügeanomalie}
	Das hinzufügen eines Eintrages in eine Tabelle kann zu einem unvollständigen Datensatz führen (unerwünschte null-werte).

	\paragraph{Änderungsanomalie}
	Wenn ein Wert, der mehrfach auftritt, nur an einer Stelle geändert wird, kann diese Änderung zu einem inkonsistenten Datensatz führen.

	\paragraph{Löschanomalie}
	Das Löschen eines Datensatzes führt aufgrund von Abhängigkeiten zur (unabsichtlichen) Löschung eines weiteren Datensatzes.

	Aus diesem Grund führen wir sogenannte Normalisierungen durch, durch die solche Anomalien verhindert werden.

	\subsubsection{Erste Normalform}
	Um die erste Normalform zu erreichen, müssen alle Attribute atomisiert werden. Das bedeutet, dass alle Attribute so weit wie möglich zerlegt werden.
	Beispielsweise könnte das Attribut "Name" in "Vorname" und "Nachname" zerlegt werden.

	\subsubsection{Zweite Normalform}
	Für die zweite Normalform ordnen wir verschiedene Attribute einzelnen festen Schlüsseln zu. Dadurch könnte es notwendig sein, Relationen zu zerlegen. Die zweite Normalform ist dann gegeben, wenn die erste Normalform vorliegt und jedes Attribut, das nicht zum Primärschlüssel gehört, von diesem voll funktional abhängig ist. Jeder Datensatz bildet dann exakt einen Sachverhalt ab.

	\subsubsection{Dritte Normalform}
	Im Zuge der Normalisierung werden zuletzt sogenannte "transitive Abhängigkeiten" aufgelöst. Das bedeutet, dass wir Abhängigkeiten auflösen, bei denen ein Nichtschlüsselattribut von einem anderen Nichtschlüsselattribut und somit nur indirekt vom Primärschlüssel abhängt. Diese Abhängigkeiten werden dann auch in eine neue Tabelle ausgelagert. Ein Beispiel wäre die Abhängigkeit von einer Postleitzahl zu einem Ort.

	\subsection{Funktionale Abhängigkeiten}
	Eine funktionale Abhängigkeit liegt vor, wenn ein Attribut eindeutig ein anderes Attribut bestimmt. Geschrieben wird so eine Abhängigkeit

	\begin{equation*}
		A \rightarrow B
	\end{equation*}

	Wenn $A$ also in zwei Zelle auftritt, muss $B$ auch übereinstimmen
	Wenn es also mehrere Zellen mit dem Wert $A$ auftreten, entstehen Redundanzen. Ein Primärschlüssel bestimmt jedes Attribut eindeutig. Dementsprechend müssen zwei Zeilen identisch sein, wenn sie den gleichen Schlüssel haben. Bei einem Datenbankentwurf ist es wichtig festzulegen, welche funktionalen Abhängigkeiten gelten sollen.

	\subsection{SQL}
	SQL ist die Sprache, über die wir mit einer Datenbank interagieren können. Mit SQL können wir die klassichen CRUD-Operationen (Create, Read, Update, Delete) sowie weitere Aktionen durchführen. SQL hier komplett abzubilden würde den Rahmen sprengen, daher hier nur die "Basics". Weiterführende Infos sind beispielsweise bei w3schools.com zu finden: https://www.w3schools.com/sql/

	\subsubsection{SELECT-Queries}
	Mit den SELECT-Queries können wir Daten aus der Datenbank abfragen
	
	\paragraph{Syntax}
	\begin{lstlisting}[language=SQL]
	SELECT [spalten] FROM [tabelle]; 
	\end{lstlisting}
	Das Semikolon ist in manchen Datenbanken optional. Dennoch schreiben wir es hier der Vollständigkeit halber dazu. Ein Beispiel für eine Query unter der angegebenen Synatx wäre

	\begin{lstlisting}[language=SQL]
	SELECT vorname, nachname, beruf FROM menschen;
	\end{lstlisting}

	Diese Query fragt die Spalten "Name", "Alter" und "Beruf" aus der Tabelle "Mensch" ab.
	Statt der Attribute können wir auch ein Sternchen (*) verwenden. Dadurch fragen wir direkt alle Spalten ab.

	\paragraph{WHERE-Bedingungen}
	Bei den Queries, die wir uns bisher angesehen haben, fragen wir immer direkt alle Zeilen ab. Eventuell wollen wir aber nur bestimmte Zeilen abfragen, in denen bestimmte Bedingungen erfüllt werden. Beispielsweise wollen wir aus einer Tabelle mit Kunden nur diejenigen Kunden erhalten, die mit Vornamen "Jürgen" heißen. Dies können wir einfach mit einer WHERE-Klausel realisieren:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE vorname = 'Juergen';
	\end{lstlisting}

	Bei WHERE-Klauseln müssen Textwerte in einzelnen Anführungszeichen angegeben werden. Numerische Werte benötigen diese nicht:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE plz = 52349;
	\end{lstlisting}

	Neben dem Gleichheitszeichen gibt es eine Vielzahl weiterer sogenannter Vergleichsoperatoren:

	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | c |}
			\hline 
			\textbf{Operator} 	& \textbf{Beschreibung} \\
			\hline
			\hline
			\textbf{$=$} 		& Ist gleich \\
			\textbf{$>$} 		& Größer als \\
			\textbf{$<$} 		& Kleiner als \\
			\textbf{$>=$} 		& Größer oder gleich \\
			\textbf{$<=$} 		& Kleiner oder gleich \\
			\textbf{$<>$} 		& Nicht gleich \\
			\hline
		\end{tabular}
	\end{center}

	Darüber hinaus gibt es noch drei Sonderoperatoren:

	\subparagraph{LIKE-Operator}
	Mit dem LIKE-Operator können quasi Schemata bzw. Vorlagen abgefragt werden. Beispielsweise möchten wir alle Kunden abfragen, deren Vorname mit "a" beginnt.
	Um den LIKE-Operator verwenden zu können, müssen wir Platzhalter (engl. wildcards) verwenden:
	
	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | c |}
			\hline
			\textbf{Symbol} 	& \textbf{Beschreibung} \\
			\hline
			\hline
			\textbf{\%} 		& Eines oder mehrere zeichen \\
			\textbf{\_} 		& Ein einzelnes Zeichen \\
			\textbf{[ ]} 		& Irgendeines der Zeichen in den Klammern \\
			\textbf{\^ [  ]} 	& Ein Zeichen, das nicht in den Klammern steht \\
			\textbf{[x-y]} 		& Ein Zeichen in dem angegebenen Bereich \\
			\hline
		\end{tabular}
	\end{center}

	Wenn wir also alle Kunden finden wollen, deren Vorname mit "a" beginnt, nutzen wir folgende Abfrage:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE vorname LIKE 'a%';
	\end{lstlisting}

	Für alle Kunden, deren Vorname an zweiter Stelle ein a, b oder c hat, sagen wir:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE vorname LIKE '_[a-c]%';
	\end{lstlisting}

	\subparagraph{IN-Operator}
	Mit dem IN-Operator können wir abfragen, ob ein Wert in einer bestimmten Menge liegt. Wenn wir also alle Kunden haben möchten, die in den Orten mit den Postleitzahlen 52349, 52399 oder 52351 wohnen, fragen wir:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE plz IN (52349, 52399, 52351);
	\end{lstlisting}

	\subparagraph{BETWEEN-Operator}
	Mit dem BETWEEN-Operator können wir fragen, ob ein Wert zwischen zwei anderen Werten liegt. Die beiden Werte sind dabei inklusiv:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE kundennummer BETWEEN 69 AND 420;
	\end{lstlisting}

	Darüber hinaus können wir mehrere WHERE-Klauseln kombinieren:

	\subparagraph{AND-Operator}
	Über AND können wir zwei WHERE-Abfragen so kombinieren, dass die Zeile dann ausgegeben wird, wenn \underline{alle} Bedingungen zutreffen:

	\begin{lstlisting}[language=SQL, caption=Abfrage aller Kunden namens "Jürgen" in 52399]
	SELECT * FROM kunden WHERE vorname = 'Juergen' AND plz = 52399;
	\end{lstlisting}

	\subparagraph{OR-Operator}
	Bei OR werden alle Zeilen ausgegeben, in denen \underline{eine} der Bedingungen zutrifft :

	\begin{lstlisting}[language=SQL, caption=Abfrage aller Kunden mit Vorname "Jürgen" oder PLZ 52341]
	SELECT * FROM kunden WHERE vorname = 'Juergen' OR plz = 52341;
	\end{lstlisting}

	\subparagraph{NOT-Operator}
	Der NOT-Operator ist dann erfüllt, wenn eine WHERE-Bedingung nicht zutrifft:

	\begin{lstlisting}[language=SQL]
	SELECT * FROM kunden WHERE NOT vorname = 'Jurgen';
	\end{lstlisting}

	\paragraph{DISTINCT}
	Das DISTINCT-Statement sorgt dafür, dass wir nur untunterschiedliche Werte aus den angegebenen Spalten bekommen:

	\begin{lstlisting}[language=SQL, caption=Postleitzahlen aller Orte mit registrierten Kunden]
	SELECT DISTINCT plz FROM kunden;
	\end{lstlisting}

	\paragraph{ORDER BY}
	Über das ORDER BY-Statement können wir eine Reihenfolge angeben, in der wir die Daten sortieren möchten. Die Reihenfolge ist je nach Zusatz ASC (ascending) oder DESC (descending) aufsteigend oder absteigend:

	\begin{lstlisting}[language=SQL, caption=Vorname und PLZ aller Kunden absteigend sortiert anhand der PLZ]
	SELECT vorname, plz FROM kunden ORDER BY plz DESC;
	\end{lstlisting}

	\paragraph{Aggregatfunktionen}
	Mit Aggregatfunktionen können wir bestimmte Operationen auf unsere abgefragten Daten anwenden. Diese Funktionen rufen wir auf bestimmte Spalten in unserer Tabelle auf:

	\subparagraph{COUNT()}
	Mit COUNT() können wir die Anzahl der abgefragten Zeilen zählen:

	\begin{lstlisting}[language=SQL, caption=Anzahl aller Kunden mit dem Vornamen "Jürgen"]
	SELECT COUNT(*) FROM kunden WHERE vorname = 'Juergen';
	\end{lstlisting}

	\subparagraph{AVG()}
	AVG() berechnet den Durchschnitt der Werte in der angegebenen Spalte.

	\begin{lstlisting}[language=SQL, caption=Durchschnittliche Bestellungen eines Kunden]
	SELECT AVG(bestellungen) FROM kunden;
	\end{lstlisting}

	\subparagraph{SUM()}
	SUM() summiert alle Werte in der angegebenen Spalte auf:

	\begin{lstlisting}[language=SQL, caption=Anzahl der Bestellungen aller Kunden]
	SELECT SUM(bestellungen) FROM kunden;
	\end{lstlisting}

	\subparagraph{MIN()}
	MIN() findet den kleinsten Wert in der angegebenen Spalte:

	\begin{lstlisting}[language=SQL, caption=Kleinste Anzahl an Bestellungen eines Kunden]
	SELECT MIN(bestellungen) FROM kunden;
	\end{lstlisting}

	\subparagraph{MAX()}
	MAX() findet dementsprechend den größten Wert in der angegebenen Spalte:

	\begin{lstlisting}[language=SQL, caption=Einzelner Kunde mit den meisten Bestellungen]
	SELECTMAX(bestellungen) FROM kunden;
	\end{lstlisting}

	\paragraph{Aliasse}
	Wir können Spalten mit dem "AS"-Statement einen temporären, individuellen Namen geben:

	\begin{lstlisting}[language=SQL, caption=Benennt die Spalte "plz" in "postleitzahl" um]
	SELECT plz AS postleitzahl FROM kunden;
	\end{lstlisting}

	\paragraph{GROUP BY}
	Durch das GROUP BY-Statement können wir Zeilen mit denselben Werten gruppieren. Diese Statements werden häufig mit Aggregatfunktionen zusammen verwendet:

	\begin{lstlisting}[language=SQL, caption=Nennt die Zahl der Kunden in den einzelnen Orten]
	SELECT COUNT(kundennummer), plz FROM kunden GROUP BY plz;
	\end{lstlisting}

	\paragraph{HAVING}
	Das HAVING-Statement ist quasi ein WHERE-Statement für GROUP-BY-Abfragen, da WHERE nicht mit Aggregatfunktionen arbeiten kann:

	\begin{lstlisting}[language=SQL, caption=Orte mit mehr als 5 Kunden]
	SELECT COUNT(kundennummer), plz 
	FROM kunden 
	GROUP BY plz 
	HAVING COUNT(kundennummer) > 5;
	\end{lstlisting}

	\paragraph{Joins}
	Mit den Join-Statements können wir mehrere Tabellen miteinander verknüpfen. Um das zu verdeutlichen, erstellen wir uns zunächst zwei Tabellen "Kunden" und "Orte":

	\begin{center}
		Kunden(\underline{Kundennummer}, Vorname, Name, Bestellungen, $\uparrow$ PLZ) \\
		Orte(\underline{PLZ}, Name)
	\end{center}

	PLZ ist also für "Kunden" ein Fremdschlüssel, der auf die Tabelle "Orte" verweist. Darüber können wir die beiden Tabellen verknüpfen:

	\begin{lstlisting}[language=SQL, caption=Wir erhalten Vornamen sowie Kundennummern und dazugehörige Ortsnamen]
	SELECT kunden.vorname, kunden.kundennummer, orte.name
	FROM kunden
	INNER JOIN orte ON kunden.plz = orte.plz;
	\end{lstlisting}

	Hierbei gibt es allerdings mehrere Arten von JOIN-Statements:

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{inner_join}
		\caption{\textbf{INNER JOIN} gibt Einträge mit zutreffenden Werten in beiden Tabellen zurück}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{left_join}
		\caption{\textbf{LEFT JOIN} gibt alle Einträge aus der linken Tabelle und Einträge mit zutreffenden Werten aus der rechten Tabelle zurück}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{right_join}
		\caption{\textbf{RIGHT JOIN} funktioniert wie LEFT JOIN, nur umgekehrt}
	\end{figure}

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{full_join}
		\caption{\textbf{FULL JOIN} gibt alle Einträge aus der linken und rechten Tabelle zurück, wenn es in einer der Tabellen einen zutreffenden Wert gibt}
	\end{figure}

	\paragraph{SELECT IN SELECT}
	Wir können SELECT-Abfragen nicht nur auf Tabellen, sondern auch auf andere SELECT-Abfragen ausführen:

	\begin{lstlisting}[language=SQL]
	SELECT kundennummer from (
		SELECT * FROM kunden
	);
	\end{lstlisting}

	\paragraph{UNION}
	Mit dem UNION-Statement können wir die Ergebnisse zweier SELECT-Abfragen kombinieren. Beide SELECT-Statements müssen dabei gleich viele Spalten mit gleichen Datentypen angeben.
	Als Beispiel fügen wir zu unseren Tabellen "Kunden" und "Orte" eine Tabelle "Zulieferer" hinzu:

	\begin{center}
		Zulieferer(\underline{ZuliefererId}, Firmenname, Produkt, $\uparrow$ PLZ) \\
	\end{center}

	Nun könnten wir die PLZs aus den Tabellen "Kunden" und "Zulieferer" zusammenführen:

	\begin{lstlisting}[language=SQL, caption=Wir sammeln sämtliche momentan benutzten PLZs in unserer Datenbank ein]
	SELECT plz FROM kunden
	UNION
	SELECT plz FROM zulieferer;
	\end{lstlisting}

	Dies unterscheidet sich von einer einfachen SELECT-Abfrage sämtlicher Postleitzahlen in "Orte" insofern, dass "Orte" auch Postleitzahlen enthalten kann, deren zugehörige Kunden und Zuliefrer schon gelöscht wurden. Dadurch erhalten wir nur die PLZs, die momentan wirklich verwendet werden.

	\subsubsection{INSERT INTO}
	Mit dem INSERT INTO-Statement können wir neue Einträge zu unserer Datenbank hinzufügen:

	\begin{lstlisting}[language=SQL, caption=Wir fügen neue Einträge zu der Kunden-Tabelle hinzu]
	INSERT INTO kunden (vorname, name, bestellungen, plz) 
	VALUES ('Juergen', 'Mustermann', 0, 52341);
	\end{lstlisting}

	Innerhalb der ersten Klammern geben wir die Spalten ein, die wir befüllen möchten. Die zweite Klammer enthält die tatsächlichen Werte, die wir einfügen möchten. Eine Kundennummer fügen wir nicht hinzu, da wir davon ausgehen, dass unsere Tabelle so konfiguriert ist, dass sie automatisch neue Primärschlüssel hinzufügt. Wichtig ist, dass wir sicherstellen, dass es für unsere PLZ bereits einen Eintrag in der "Orte"-Tabelle gibt.

	\subsubsection{DELETE FROM}
	Mit dem DELETE FROm-Statement können wir Einträge aus unserer Tabelle entfernen:

	\begin{lstlisting}[language=SQL, caption=Wir entfernen alle Jürgens aus unserer Kundentabelle]
	DELETE FROM kunden WHERE vorname = 'Juergen';
	\end{lstlisting}

	Für DELETE FROM können die gleichen WHERE-Klauseln verwendet werden, die wir schon für SELECT erläutert haben.

	\subsection{Der DatabaseConnector}
Um durch ein Java-Programm auf eine Datenbank zugreifen zu können, benutzen wir im Schulrahmen die Klassen "DatabaseConnector" und "QueryResult". Die Dokumentation dieser Klassen findet ihr \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp\_SII/if/Dokumentation\_ZA-IF\_GK-LK\_ab\_2018\_2021\_12\_22.pdf#page=31}{\underline{hier für den DatabaseConnector}} und \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp\_SII/if/Dokumentation\_ZA-IF\_GK-LK\_ab\_2018\_2021\_12\_22.pdf#page=32}{\underline{hier für das QueryResult}}

	\subsubsection{Beispiel}
	Ein Beispielprogramm zur Interaktion mit einer Datenbank in Java könnte wie folgt aussehen:

	\begin{lstlisting}[language=Java]
	public class Beispiel {
		DatabaseConnector connector;

		public Beispiel() {
			this.connector = DatabaseConnector(
				pIp="localhost",
				pPort="5432",
				pDatabase="kundendb",
				pUsername="admin",
				pPassword="admin"
			);
		}

		public void neuerKunde(String pVorname, String pNachname, int pPlz) {
			if (!checkPlzExists(pPlz)) {
				throw new SQLException("PLZ existiert nicht; bitte hinzufuegen");
			}

			this.connector.executeStatement(
				"INSERT INTO kunden (vorname, nachname, bestellungen, plz) \
				VALUES ('"+ pVorname +"', '"+ pNachname +"', 0, "+ pPlz +");"
			);
		}

		public String[] holAlleKunden() {
			this.connector.executeStatement("SELECT * FROM kunden;");
		
			// Prueft auf Fehler
			String error = this.connector.getErrorMessage();
			if (error != null) {
				throw new SQLException("Irgendwas ging schief: " + error);
			}

			QueryResult result = this.connector.getCurrentQueryResult();
			String[][] data = result.getData();
			String[] out = new String[data.length];
		
			for (int i = 0; i< data.length; i++) {
				out[i] = data[i][0];
			}
			return out;
		}

		public void fuegeOrtHinzu(int pPlz, String pName) {
			if (checkPlzExists(pPlz)) {
				throw new SQLException("PLZ existiert bereits");
			}
			this.connector.executeStatement(
				"INSERT INTO orte (plz, name) \
				VALUES "+ pPlz +"'"+ pName +"');"
			);
		}

		public boolean checkPlzExists(int plz) {
			this.connector.executeStatement("SELECT plz FROM orte WHERE plz = " + String.valueOf(plz) + ";");

			if (this.connector.getErrorMessage() != null) {
				throw new SQLException("Irgendwas ging schief");
			}
			return this.connector.getCurrentQueryResult() != null;
		}
	}
	\end{lstlisting}


	\section{Nicht-Lineare Datenstrukturen}
	
	Unterschied zu linearen Datenstrukturen: Ein Objekt kann mehr als einen Nachfolger haben.
	
	\subsection{Bäume}
	
	\subsubsection{Komponenten}
	
	\begin{itemize}
		\item Knoten (Vertex): speichert Daten
		\item Kante (Edge): verbindet Knoten
		\item Wurzel (Root): Knoten, der keinen Vorgänger hat
		\item Blatt (Leaf): Knoten, der keinen Nachfolger hat
		\item Vaterknoten (Parent): Knoten, der einen Nachfolger hat
		\item Kindknoten (Child): Knoten, der einen Vorgänger hat
	\end{itemize}
	
	\subsubsection{Maße}
	
	\begin{itemize}
		\item Ordnung (Order) eines Baums: Anzahl der Kinder, die ein Knoten höchstens haben darf
		\item Grad (Degree) eines Knotens: Anzahl der Kinder, die ein Knoten hat
		\item Höhe (hight) eines Baums: Länge des Pfades des Blattes, das am weitesten von der Wurzel entfernt ist ($\rightarrow$ leerer Baum: Höhe $0$; Baum mit nur Wurzel: Höhe $1$)
		\item Tiefe (depth) eines Knotens: Anzahl der Knoten auf dem Pfad von der Wurzel zum entsprechenden Knoten
		\item Tiefe (depth) eines Baumes: Tiefe des tiefsten Knotens dieses Baumes (gleichbedeutend mit der Höhe des Baumes)
		\item Niveaus (level): Knoten, welche die gleiche Tiefe haben, werden zu einem Niveau zusammengefasst
	\end{itemize}
	
	\subsubsection{Binärbäume}
	
	\begin{itemize}
		\item Baum zweiter Ordnung
		\item effiziente Suche und Sortierung möglich
		\item da höchstens zwei Kinderknoten vorhanden sind, werden diese als linkes (left) und rechtes (right) Kind bezeichnet
		\item äquivalente Definition: Ein Binärbaum ist entweder leer, oder er besteht aus einer Wurzel mit einem linken und einem rechten Teilbaum, die wiederum Binärbäume sind. 
	\end{itemize}
	
	\paragraph{Binärer Suchbaum}
	
	\begin{itemize}
		\item sortierter Binärbaum
		\item einfache Suche
		\item implementation des Interfaces "ComparableContent" notwendig um Vergleichbarkeit zu garantieren und somit eine Sortierung zu ermöglichen
		\item jeder Knoten ist größer als sein linker und kleiner als sein Rechter Nachfolger
	\end{itemize}
	
	\subparagraph{Einfügen in binäre Suchbäume}
	
	Um die Sortierung beizubehalten ist es wichtig, wo ein neuer Knoten eingefügt wird. Der neue Knoten muss die Eigenschaft erfüllen, dass ein linker Nachfolger kleiner und ein rechter Nachfolger größer als sein Vorgänger sein muss. Um das zu gewährleisten muss Folgendes getan werden: 
	
	\begin{enumerate}
		\item Das einzufügende Element wird mit der Wurzel des Suchbaumes verglichen. Ist es kleiner, wird es links einsortiert, ist es größer rechts. Die genaue Implementation des Baumes entscheidet, ob bei gleichem Wert das Objekt rechts oder links eingeordnet wird.
		\item Im entsprechenden Teilbaum wird diese Operation wiederholt. 
		\item Gibt es keinen weiteren Teilbaum zum Vergleich, ist die Stelle gefunden, an die das neue Element angefügt werden kann.
	\end{enumerate}
	
	\subparagraph{Löschen aus binären Suchbäumen}
	
	Auch beim Löschen aus einem Suchbaum muss die Ordnung erhalten bleiben. Daher gibt es Folgendes zu beachten: 
	
	\begin{enumerate}
		\item Der zu löschende Knoten muss identifiziert werden. 
		\item Ist er ein Blatt, kann er ohne weitere Schritte gelöscht werden.
		\item Besitzt er nur einen Nachfolger, wird dieser nach dem Löschen seine Stelle einnehmen.
		\item Besitzt der rechte Nachfolger keinen linken Nachfolger, wird der zu löschende Knoten durch ihn ersätzt. Dadurch bekommt er als linken Nachfolger den linken Nachfolger des gelöschten Knotens.
		\item Besitzt auch der rechte Nachfolger zwei Nachfolger, muss der zu löschende Knoten durch einen anderen Knoten ersätzt werden, um die Ordnung nicht zu verändern. Hierzu wird der im rechten Teilbaum der linkeste Knote gesucht (immer wieder links bis kein linker Nachfolger mehr existiert) (es wäre auch der rechteste Knoten im linken Teilbaum möglich) und an die Stelle des zu löschenden Knotens gesetzt. Danach muss er von seiner ursprünglichen Position gelöscht werden.
	\end{enumerate}
	
	\paragraph{Modellierung}
	
	\begin{itemize}
		\item generische Klasse
		\item innere Klasse: Knoten
		\item jeder Binärbaum hat genau einen Knoten (Wurzel)
		\item jeder Knoten hat einen Inhalt, einen linken und einen rechten Nachfolger (Nachfolger sind Binärbäume)
		\item Methoden
		\begin{itemize}
			\item 3 Konstruktoren (leerer Baum; übergebener Inhalt ohne Nachfolger; übergebener Inhalt und übergebene Nachfolger)
			\item Setter und Getter für Node, linken und rechten Teilbaum
		\end{itemize}
	\end{itemize}
	
	\paragraph{Traversierung}
	
	\begin{itemize}
		\item Durchlaufen des Baumes
		\item alle Knoten werden "besucht" (z. B. um sie auszugeben)
		\item Unterscheidung der Reihenfolge
		\begin{enumerate}
			\item Preorder-Traversierung
			\begin{itemize}
				\item Wurzelknoten wird zuerst ausgegeben
				\item danach wird sein linker Nachfolger in der Preorder-Reihenfolge durchlaufen
				\item zum Schluss wird der rechte Nachfolger in der Preorder-Reihenfolge durchlaufen
			\end{itemize}
			\item Inorder-Traversierung
			\begin{itemize}
				\item zuerst wird der linke Teilbaum in der Inorder-Reihenfolge durchlaufen
				\item danach wird der Wurzelknoten ausgegeben
				\item zum Schluss wird der rechte Teilbaum in der Inorder-Reihenfolge durchlaufen
			\end{itemize}
			\item Postorder-Traversierung
			\begin{itemize}
				\item zuerst wird der linke Teilbaum in der Postorder-Reihenfolge durchlaufen
				\item dann wird der rechte Teilbaum in der Postorder-Reihenfolge durchlaufen
				\item zum Schluss wird der Wurzelknoten ausgegeben
			\end{itemize}
		\end{enumerate}
	\end{itemize}

	\subsection{Graphen}
	Ein Graph ist eine nicht-lineare Datenstruktur, die genutzt werden kann, um Netzwerke darzustellen. Beispielsweise kann man Graphen nutzen, um Freundesgruppen, internationale Beziehungen oder Verkehrsinfrastruktur zu modellieren. Mit Graphen lassen sich eine Vielzahl von Sachzusammenhängen abstrahieren.
	Ein Graph besteht dabei aus zwei wesentlichen Komponenten:

	\paragraph{Knoten}
	Die Knoten (engl. Vertex, pl. Vertices) beschreiben die konkreten Entitäten, die wir in unserem Graphen abbilden wollen. In einer Freundesgruppe könnten dies zum Beispiel "Menschen" sein.In Java benutzen wir die Klasse "Vertex", um Knoten zu implementieren. Die Dokumentation \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp_SII/if/Dokumentation_ZA-IF_GK-LK_ab_2018_2021_12_22.pdf#page=29}{\underline{findet ihr hier}}.

	\paragraph{Kanten}
	Mit Kanten (engl. Edge) werden die Beziehungen zwischen den einzelnen Knoten dargestellt, wobei eine Kante immer genau zwei Knoten verbindet. In Java kann man für die Klasse "Edge" nutzen, deren Dokumentation \href{https://www.schulentwicklung.nrw.de/lehrplaene/upload/klp_SII/if/Dokumentation_ZA-IF_GK-LK_ab_2018_2021_12_22.pdf#page=30}{\underline{ist hier zu finden}}.

	\subsubsection{Gerichtete Graphen}
	Ein Graphen kann so verwendet werden, dass eine Kante explizit vom einen Knoten zum anderen zeigt, aber nicht umgekehrt. In diesem Fall gibt die Kante eine Richtung vor - der Graph ist also ein gerichteter Graph

	\subsubsection{Gewichtete Graphen}
	Neben einer Richtung können wir Kanten auch ein Gewicht geben. Dieses kann je nach Zusammenhang verschiedene Funktionen erfüllen. In einem Verkehrsnetz könnte ein Gewicht eventuell die Zeit beschreiben, die man benötigt, um von einem Knoten zu einem anderen zu kommen.

	\subsubsection{Schreibweise}
	Graphen können auf mehrere Arten aufgeschrieben werden:
	
	\paragraph{Graphenschreibweise}
	Ganz klassich kann ein Graph visualisiert mit Kanten und Knoten gezeichnet werden:

	\begin{figure}[h!]
		\centering
		\includesvg[width=5.5cm]{example_graph}
		\caption{Ein Beispiel für einen gerichteten und gewichteten Graphen}
	\end{figure}

	\paragraph{Adjazenzmatrix}
	Ein Graph kann auch in einer Matrix dargestellt werden. Eine Matrix für den gerade gezeichneten Graphen sieht so aus:

	
	\begin{center}
		\def\arraystretch{1.1}
		\begin{tabular}{ | c | c | c | c | }
			\hline 
						& \textbf{A} 	& \textbf{B} 	& \textbf{C} 	\\
			\textbf{A} 	& 0 			& 1 			& 3 			\\
			\textbf{B} 	& 				& 0 			& 				\\
			\textbf{C} 	& 3 			& 12 			& 0 			\\ 
			\hline
		\end{tabular}
	\end{center}

	\subsubsection{Algorithmen}
	Es gibt eine Vilzahl von Algorithmen, um Graphen-bezogene Probleme zu lösen.

	\paragraph{Einen Knoten finden}
	Um sämtliche Knoten abzufragen, mit denen ein Ursprungsknoten $v$ verbunden ist, gibt es zwei sehr ähnliche Algorithmen, die beinahe identisch arbeiten:

	\subparagraph{Breitensuche (BFS)}
	Die Breitensuche beginnt bei einem Knoten und fügt alle verbunden Knoten in eine Queue ein. Danach arbeitet sie diese Queue ab und wiederholt das Anfügen, bis alle Knoten besucht wurden. 

	\begin{lstlisting}[caption=Ein Beispiel für BFS in Pseudocode]
	method BFS(G, v) {
		Initialisiere Queue Q
		Q.enqueue(v)
		while Q nicht leer {
			v = Q.dequeue()

			for Nachbarn w von v {
				markiere w als besucht
				Q.enqueue(w) // um spaeter die Nachbarn von w zu besuchen
			}
		}
	}
	\end{lstlisting}

	\begin{lstlisting}[language=Java, caption=Ein Beispiel für BFS in Java]
	public static void bfs(Graph g, Vertex v) {
		g.setAllVertexMarks(false);

		Queue<Vertex> q = new Queue<Vertex>();

		q.enqueue(v);

		while (!queue.isEmpty()) {
			v = q.front();
			q.dequeue();

			for (Vertex w : g.getNeighbours(v)) {
				if (!w.isMarked()) {
					w.setMark(true);
					q.enqueue(w);
				}
			}
		}
	}
	\end{lstlisting}

	\newpage

	\subparagraph{Tiefensuche (DFS)}
	DFS funktioniert genau wie die BFS, allerdings wird statt einer Queue ein Stack verwendet:

	
	\begin{lstlisting}[caption=Ein Beispiel für DFS in Pseudocode]
	method DFS(G, v) {
		Initialisiere Stack s
		s.push(v)
		while s nicht leer {
			v = s.pop()

			for Nachbarn w von v {
				markiere w als besucht
				s.push(w) // um spaeter die Nachbarn von w zu besuchen
			}
		}
	}
	\end{lstlisting}

	\paragraph{Kürzester Weg}
	Ein häufiges Graphenproblem ist es auch, den kürzesten bzw. "günstigsten" Weg von einem Knoten zu einem anderen in einem gewichteten Graphen zu finden. Auch dafür gibt es mehrere Algorithmen:

	\subparagraph{Dijkstra}
	Der Dijkstra-Algorithmus ist ein sogenannter "Greedy"-Algorithmus, der Knoten für Knoten die Entfernungen berechnet. Dabei geht er folgendermaßen vor:

	\begin{enumerate}
		\item Weise jedem Knoten die Eigenschaft "Distanz" und "Vorgänger" zu
		\item Setze die Distanz des Startknotens auf "0"
		\item Setze die Distanz aller anderen Knoten auf $\infty$
		\item Wähle unter den nicht besuchten Knoten den mit der niedrigsten Distanz aus
			\begin{enumerate}
				\item Speichere, dass dieser Knoten besucht wurde
				\item Berechne die Gesamtdistanz aller Nachbarknoten über das Gewicht der Kante zu dem Knoten und der Gesamtdistanz des aktuellen Knotens
				\item Wenn dieser Wert kleiner ist als der Wert, der dort bereits gespeichert ist, aktualisiere die Distanz und setze den aktuellen Knoten als neuen Vorgänger
			\end{enumerate}
	\end{enumerate}

	Allerdings findet Dijkstra bei Graphen mit negativen Kanten nicht immer ein optimales Ergebnis. Daher muss man für solche Graphen andere Algorithmen wie Bellman Ford verwenden. Mit gerichteten Graphen wiederum hat Dijkstra kein Problem.

	\newpage

	Ein Pseudocode des Dijkstra-Algirithmus könnte wie folgt aussehen:

	\begin{lstlisting}[caption=Dijkstra in Pseudocode]
	method Dijkstra(G, v) {
		Initialisiere Liste L

		For knoten w in G {
			Setze Distanz von w auf unendlich
			Setze Vorgaenger von w auf null
			Fuege w in L ein
		}

		Setze Distanz zu v auf 0

		While L ist nicht leer {
			v = Knoten mit geringster Distanz in L
			Entferne v aus L

			For Nachbar w von v, der noch in L ist {
				c = Distanz von v + Gewicht v-w

				Wenn c < Distanz von w {
					Setze Distanz von w auf c
					Setze Vorgaenger von w auf v
				}
			}
		}
	}
	\end{lstlisting}

	\paragraph{Minimale Spannbäume (MST)}
	Ein Teilhraph $H$ eines ungerichteten Graphen $G$ heißt Spannbaum, wenn H ein Baum aus den Knote von G ist. Ein Spannbaum S eines gewichteten, ungerichteten Graphen G heißt minimaler Spannbaum von G, wenn S unter allen Spannbäumen von G ein minimales Gewicht besitzt. Das Ziel eines minimalen Spannbaums ist es, alle Knoten eines Graphen möglichst kostengünstig miteinander zu verbinden. Um diesen Baum zu generieren, können wir den Kruskal- oder den Prim-Algorithmus verwenden:

	\subparagraph{Kruskal}
	Der Kruskal-Algorithmus arbeitet mit den Kanten des Graphen: er sortiert die Kanten nach Gewicht in aufsteigender Reihenfolge und fügt anschließend immer die Kante mit dem kleinsten Gewicht zum Graphen hinzu, falls beim hinzufügen der Kante keine Kreise im Graphen entstehen. Diesen Vorgang wiederholt der Algorithmus so lange, bis alle Knoten im minimalen Spannbaum verbunden sind.

	\begin{lstlisting}[caption=Der Kruskal-Algorithmus in Pseudocode]
	method kruskal(G) {
		V = Liste mit Knoten von G
		E = Liste mit Kanten von G

		MST = neuer Graph mit Knoten V

		sortiere E aufsteigend

		For Kante e aus E {
			Entferne e aus E
			Wenn MST mit hinzugefuegter Kante e keine Kreise enthaelt {
				fuege e zu MST hinzu
			}
		}
	}
	\end{lstlisting}


	\section{Formale Sprachen, Grammatiken und Automaten}
	
	\subsection{Formale Sprachen}
	
	\subsubsection{Definition}
	
	\begin{itemize}
		\item Menge von Symbolanordnungen
		\item vorgegebene Regeln
		\item Syntax: erlaubte Ausdrücke
		\item Semantik: Bedeutung von Ausdrücken (in formalen Sprachen nicht definiert)
	\end{itemize}
	
	\subsubsection{Alphabet}
	
	\begin{itemize}
		\item Menge zulässiger Zeichen für eine Sprache
		\item Bezeichnung: $\Sigma$
	\end{itemize}
	
	\subsubsection{Wort}
	
	\begin{itemize}
		\item beliebige endliche Aneinanderreihung von Zeichen des Alphabets
		\item leeres Wort ($\epsilon$): Wort ohne Buchstaben
		\item Menge aller Worte aus dem Alphabet $\Sigma$ inklusive $\epsilon$: $\Sigma$*
		\item $\Sigma$* kann Worte mit unendlicher Länge enthalten und enthält daher unendlich viele Worte
	\end{itemize}
	
	\subsubsection{Syntaxdiagramme}
	
	\begin{itemize}
		\item mehrere Symbole hintereinander
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Sequence}
			\caption{In den Rechtecken stehen Zeichen des Alphabets. Diese werden nacheinander angefügt, um ein Wort zu bilden. Diese Kette kann beliebig lang sein.}
		\end{figure}	
		\item Iteration (0 - $\infty$)
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Iteration_0-n}
			\caption{In dem Rechteck steht ein Zeichen des Alphabets. Dieses kann beliebig oft aneinandergereiht werden, muss aber nicht verwendet werden.}
		\end{figure}	
		\item Iteration (1 - $\infty$)
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Iteration_1-n}
			\caption{In dem Rechteck steht ein Zeichen des Alphabets. Dieses muss mindestens einmal, kann aber auch beliebig oft verwendet werden.}
		\end{figure}	
		\item Auswahl
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Selection}
			\caption{In den Rechtecken stehen Zeichen des Alphabets. Von diesen muss genau eines an das entstehende Wort angehängt werden.}
		\end{figure}	
		\item Option
		\begin{figure}[H]
			\centering
			\includesvg[width=9.0cm]{Syntaxdiagramm_Option}
			\caption{In dem Rechteck steht ein Zeichen des Alphabets. Dieses kann genau einmal oder gar nicht an das entstehende Wort angehängt werden.}
		\end{figure}	
		\item Bezug auf andere Syntaxdiagramme
		\begin{figure}[H]
			\centering
			\includesvg[width=15.0cm]{Syntaxdiagramm_in_Syntaxdiagramm_1}
			\caption{Dies ist ein Beispiel für ein Syntaxdiagramm. Mit dem von links kommenden "Anfangspfeil" kann ein Syntaxdiagramm benannt werden.}
		\end{figure}	
		\begin{figure}[H]
			\centering
			\includesvg[width=15.0cm]{Syntaxdiagramm_in_Syntaxdiagramm_2}
			\caption{In den Rechtecken können neben Zeichen des Alphabets auch Namen anderer Syntaxdiagramme stehen. Dann wird statt ein Zeichen an das entstehende Wort anzuhängen dieses Syntaxdiagramm ausgeführt.}
		\end{figure}	
	\end{itemize}
	
	\subsection{Grammatiken}
	
	\begin{itemize}
		\item eine Grammatik erzeugt (genau) eine Sprache
		\item mehrere Grammatiken können die selbe Sprache erzeugen
		\item Grammatik $G = (N, \Sigma, S, P)$
		\item $N$: Menge der Nichtterminalsymbole ("Variablen")
		\item $\Sigma$: Menge der Terminalsymbole / Alphabet
		\item $S$: Startsymbol mit $S \in N$
		\item $P$: Menge der Produktionsregeln \\
		Beispiele:
		\begin{itemize}
			\item A $\rightarrow$ B
			\item A $\rightarrow$ B, B $\rightarrow$ A
			\item A $\rightarrow$ 0 $\mid$ 1
			\item A $\rightarrow$ 0B $\mid$ 100B $\mid$ $\epsilon$
		\end{itemize}
		\item $N \cap \Sigma = \varnothing$ (nichts ist gleichzeitig Terminal- und Nichtterminalsymbol)
	\end{itemize}
	
	\subsubsection{Reguläre Grammatiken}
	
	Man unterscheidet zwischen rechts- und linksregulären Grammatiken. Ist dies nicht genauer spezifiziert, sind meist rechtsreguläre Grammatiken gemeint. Eine (rechts-) reguläre Grammatik $G = (N, \Sigma, S, P)$ hat in der Menge der Produktionsregeln $P$ nur Produktionsregeln der Form:
	\begin{itemize}
		\item $A = \sigma B$
		\item $A = \sigma$
	\end{itemize}
	Dabei gilt: 
	\begin{itemize}
		\item $A, B \in N$
		\item $\sigma \in \Sigma$
		\item $A = B$ ist erlaubt
	\end{itemize}
	Bei rechtsregulären Grammatiken werden also Worte nur nach rechts erweitert. Entsprechend werden bei linksregulären Grammatiken Worte nur nach links erweitert ($B \sigma$ statt $\sigma B$). Eine Sprache, die durch mindestens eine reguläre Grammatik erzeugt werden kann, nennt man reguläre Sprache.
	
	\subsection{Automaten}
	
	\subsubsection{Deterministische endliche Automaten (DEA)}
	
	$A = (Q, q_0, \Sigma, F, \delta)$
	\begin{itemize}
		\item $Q$: endliche Menge von Zuständen
		\item $q_0$: Startzustand mit $q_0 \in Q$
		\item $\Sigma$: endliches Eingabealphabet
		\item $F$: Menge der Endzustände mit $F \subseteq Q$
		\item $\delta$: Übergangsfunktion mit $\delta: Q \times \Sigma \rightarrow Q$ \\
		$\implies$ ordnet jedem Paar $q \in Q$, $\sigma \in \Sigma$ einen eindeutigen Folgezustand $\delta(q,\sigma) = q'$ zu
	\end{itemize}
	
	\subsubsection{Nichtdeterministische endliche Automaten (NEA)}
	
	$A = (Q, q_0, \Sigma, F, \delta)$
	\begin{itemize}
		\item $Q$: endliche Menge von Zuständen
		\item $q_0$: Startzustand mit $q_0 \in Q$
		\item $\Sigma$: endliches Eingabealphabet
		\item $F$: Menge der Endzustände mit $F \subseteq Q$
		\item $\delta$: Übergangsrelation mit $\delta: Q \times \Sigma \rightarrow Q^n$ \\
		$\implies$ ordnet jedem Paar $q \in Q$, $\sigma \in \Sigma$ eine Menge von Folgezuständen $\delta(q,\sigma) \subseteq Q$ zu
	\end{itemize}
	
	\subsubsection{Visualisierung}
	
	\begin{figure}[H]
		\centering
		\includesvg[width=6.0cm]{Automats_Visualisation_Example}
		\caption{Die Kreise symbolisieren Zustände. In ihnen stehen Bezeichnungen. Der Startzustand wird durch ein Dreieck gekennzeichnet. Der  Endzustand / die Endzustände werden durch einen doppelten Kreis gekennzeichnet. Start- und Endzustand können, müssen aber nicht identisch sein. Die Pfeile symbolisieren Übergänge. An ihnen stehen Zeichen des Eingabealphabets. Sie können von einem Zustand auf einen anderen oder den diesen selbst zeigen. Gehen mehrere Pfeile mit dem selben Zeichen des Alphabets von einem Zustand ab, handelt es sich um einen NDE, ansonsten um einen DEA.}
	\end{figure}	
		
	\subsubsection{Zustandstabelle}
		
	Automaten lassen sich auch in Form einer Zustandstabelle darstellen. In diesen stehen de Zeilen für die einzelnen Zustände und die Spalten für die Zeichen des Eingabealphabets. In den Zellen steht der damit jeweils erreichte Folgezustand bzw. die Menge der hiermit zu erreichenden Folgezustände. Auch der Fehlerzustand kann hier aufgeführt werden.\\
	Beispiel:
		
	\begin{center}
		\begin{tabular}{ |c|c|c|c| } 
 			\hline
  			& Zustand1 & Zustand2 & $\ldots$ \\ 
  			\hline
 			Zeichen1 & Zustand2 & \{Zustand1, Zustand2\} & $\ldots$ \\ 
			\hline
 			Zeichen2 & F & Zustand2 & $\ldots$ \\ 
 			\hline
 			F & F & F & $\ldots$ \\
 			\hline
 			$\ldots$ & $\ldots$ & $\ldots$ & $\ldots$ \\
 			\hline
		\end{tabular}
	\end{center}
		
	\subsubsection{Automaten und reguläre Grammatiken}
		
	\paragraph{Zentrale Erkenntnisse}
	\begin{itemize}
		\item zu jedem endlichen Automaten gibt es eine reguläre Grammatik, die exakt die von dem Automaten erkannte Sprache erzeugt
		\item zu jeder regulären Grammatik gibt es einen endlichen Automaten, der exakt die von der Grammatik erzeugte Sprache erkennt
		\item daher ist jede formale Sprache, die von einem endlichen Automaten erkannt wird, eine reguläre Sprache
		\item reguläre Grammatiken und endliche Automaten lassen sich in einander umwandeln
		\item daher gibt es zu jeder regulären Grammatik ein Verfahren, mit dem festgestellt werden kann, ob ein beliebiges gegebenes Wort zu dieser Grammatik gehört
	\end{itemize}
	
	\paragraph{Grenzen endlicher Automaten}
	Endliche Automaten können nur mit regulären Sprachen arbeiten. Sie können beispielsweise keine Palindrome oder korrekte Klammerung erzeugen, denn hierbei hängt das Ende vom Anfang ab und es gilt:
	\begin{itemize}
		\item Ist eine Sprache regulär, muss sie nicht mitzählen können.
		\item Automaten haben kein unbeschränktes Gedächtnis.
	\end{itemize}
	
	\begin{figure}[H]
		\centering
		\includesvg[width=6.0cm]{Automats_Example}
		\caption{Dies ist ein Beispiel für einen Automaten, das im Folgenden die Erklärung verdeutlichen soll.}
	\end{figure}	
		
	\paragraph{Automat $\rightarrow$ reguläre Grammatik}
	\begin{itemize}
		\item die Zustände des Automaten werden zu Nichtterminalsymbolen der Grammatik
		\item die Zeichen des Eingabealphabets des Automaten werden zu Zeichen des Alphabets bzw. Terminalsymbole der Grammatik
		\item der Startzustand des Automaten wird zum Startsymbol der Grammatik
		\item die Produktionsregeln der Grammatik können aus dem visualisierten Automaten abgeleitet werden: 
		\begin{figure}[H]
			\centering
			\includesvg[width=15.0cm]{Automats_Example}
			\caption{Dies ist ein Beispiel für einen Automaten, das im Folgenden die Erklärung verdeutlichen soll.}
		\end{figure}	
		\begin{itemize}
			\item kann von einem Zustand aus in den Endzustand übergegangen werden, wird der Produktionsregel für das entsprechende Nichtterminalsymbol die Umwandlung in das Terminalsymbol hinzugefügt, das dem Zeichen des Eingabealphabets entspricht, welches verwendet wird, um den Endzustand zu erreichen \\
			Beispiel: $A \rightarrow 1$, da von A in den Endzustand B übergegangen werden kann, wenn die 1 gewählt wird.
			\item für jeden Übergang des Automaten wird der Grammatik eine Produktionsregel hinzugefügt, bei der auf der linken Seite das Nichtterminalsymbol steht, das dem Zustand am stumpfen Ende des Pfeils entspricht und auf der rechten Seite zuerst das Terminalsymbol / Symbol des Eingabealphabets, das am Pfeil steht und danach das Nichtterminalsymbol, das dem Zustand entspricht, der an der Spitze des Pfeils steht \\
			Beispiel: $A \rightarrow 0A$ und $A \rightarrow 1B$
		\end{itemize}
		Insgesamt ergibt sich für dieses Beispiel: \\
		$A \rightarrow 0A \mid 1B \mid 1$ \\
		$B \rightarrow 0A \mid 1B \mid 1$
	\end{itemize}
	
	\paragraph{reguläre Grammatik $\rightarrow$ NEA}
	\begin{itemize}
		\item die Nichtterminalsymbole der Grammatik werden zu Zuständen des Automaten
		\item die Terminalsymbole der Grammatik werden zu Buchstaben des Eingabealphabets des Automaten
		\item das Startsymbol der Grammatik wird zum Startzustand des Automaten
		\item die Produktionsregeln der Grammatik werden als Pfeile des Automaten dargestellt. Außerdem werden aus ihnen die Endzustände abgeleitet. Dabei gilt:
		\begin{itemize}
			\item ein Pfeil zeigt von dem Zustand, der dem Nichtterminalsymbol auf der linken Seite der Produktionsregel entspricht, zu dem Zustand, der auf der rechten Seite der Produktionsregel steht. An dem Pfeil steht das Zeichen des Eingabealphabets, das dem Terminalsymbol auf der rechten Seite der Produktionsregel entspricht
			\item steht auf der rechten Seite der Produktionsregel kein Nichtterminalsymbol, zeigt ein Pfeil von dem Zustand, der dem Nichtterminalsymbol auf der linken Seite der Grammatik entspricht, in einen Endzustand
			\item es bietet sich an, falls es zwei Produktionsregeln gibt, die auf der linken Seite das selbe Nichtterminalsymbol und auf der rechten Seite das selbe Terminalsymbol haben, von denen aber eine auf der rechten Seite außerdem ein Nichtterminalsymbol hat, den Zustand, der diesem Nichtterminalsymbol entspricht, zum Endzustand zu machen
		\end{itemize}
	\end{itemize}
	
	\paragraph{NEA $\rightarrow$ DEA}
	\begin{itemize}
		\item bilden der Potenzmenge von $N$: es werden alle möglichen Kombinationen von Zuständen ermittelt, die in dem NEA vorkommen. Die leere Menge gehört hier theoretisch zu, hat aber keinen Nutzen
		\item Kombinationen, die einen oder mehrere Startzustand / Startzustände enthalten werden in die linke Spalte einer Tabelle geschrieben, sodass jede Zeile der Tabelle für eine Kombination von Zuständen steht
		\item die Menge(n), die mindestens einen Startzustand enthält / enthalten, wird / werden mit einem $>$ und die Menge(n), in denen mindestens eine Endzustand vorkommt mit * markiert
		\item in die erste Zeile werden alle Buchstaben des Eingabealphabets geschrieben, sodass jede Spalte für eines dabon steht
		\item in die restlichen Zellen der Tabelle werden Mengen von Zuständen eingetragen, die erreicht werden können, wenn von den Zuständen in der linken Spalte ausgegangen wird und dem Pfeil mit dem Zeichen aus der ersten Zeile gefolgt wird
		\item tritt hierbei eine Zustandskombination auf, die nicht in der Tabelle steht, wird diese in einer neuen Zeile ergänzt
		\item nun kann diese Tabelle als Zustandstabelle für den DEA, der erzeugt werden soll, betrachtet werden. Es werden also alle in der linken Spalte stehenden Kombinationen aus Zuständen als einzelne Zustände aufgefasst und eingezeichnet. Aus der Tabelle kann nun abgelesen werden, welche Verbindungen mit welchen Zeichen des Alphabets (oberste Zeile) auf welche anderen Zustände (mittlere Zellen der Tabelle) eingezeichnet werden müssen
	\end{itemize}
	
	\subsubsection{Kellerautomaten}
	
	\begin{itemize}
		\item deterministischer endlicher Automat erweitert um einen Speicher (Stack / "Kellerspeicher")
		\item Sprachen mit Kontext (Bsp.: Palindrome, Klammern)
		\item $A = (Q, \Sigma, K, \delta, q_0, \#, F)$
		\begin{itemize}
			\item $Q$: nicht leere, endliche Menge von Zuständen
			\item $\Sigma$: nicht leeres, endliches Eingabealphabet (zur besseren Unterscheidung von $K$ meist kleine Buchstaben)
			\item $K$: nicht leeres, endliches Kelleralphabet (zur besseren Unterscheidung von $\Sigma$ meist große Buchstaben)
			\item $\delta$: Übergangsfunktion \\
			$\implies$ ordnet jeder Kombination aus einem Zustand, einem Eingabezeichen und einem Kellerzeichen eindeutig einen Folgezustand und eine Kelleroperation (push($k$) $\rightarrow$ $k$ zu Kellerspeicher hinzufügen ($k \in K$), pop() $\rightarrow$ oberstes Element von Kellerspeicher entfernen, nop $\rightarrow$ nichts) zu
			\item $q_0 \in Q$: Startzustand
			\item $\# \in K$: Anfangssymbol im Keller
			\item $F \subseteq Q$: Menge der Endzustände
		\end{itemize}
	\end{itemize}
	
	\paragraph{Beispiel}
	
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			alter Zustand & Eingabezeichen & oberstes Kellerzeichen & neuer Zustand & Kellerpoeration & Nummer der Regel \\
			\hline
			$z_0$ & $a$ & $\#$ & $z_0$ & push($A$) & 1. Regel \\
			\hline
			$z_0$ & $a$ & $A$ & $z_0$ & push($A$) & 2. Regel \\
			\hline
			$z_0$ & $b$ & $A$ & $z_1$ & pop() & 3. Regel \\
			\hline
			$z_1$ & $b$ & $A$ & $z_1$ & pop() & 4. Regel \\
			\hline
			$z_1$ & $\epsilon$ & $\#$ & $z_2$ & nop & 5. Regel \\
			\hline
		\end{tabular}
	\end{center}
	
	\begin{figure}[!h]
		\centering
		\includesvg[width=12.0cm]{Automats_Example_Kellerautomat_Visualisation}
		\caption{Die Zustände werden als Kreise dargestellt. Dabei wird der Startzustand durch ein Dreieck und der / die Endzustand / Endzustände durch einen doppelten Kreis dargestellt. Übergänge werden durch Pfeile gekennzeichnet. An diesen stehen das oberste Kellerzeichen, das Eingabezeichen und die Kelleroperation, die diesen Übergang charakterisieren im Format $(k_0, \sigma): k_2 k_1$ für $\sigma \in \Sigma$ und $k_0, k_1, k_2 \in K$. Dabei wird $k_0$ aus dem Kellerspeicher entfernt und $k_1$ und $k_2$ von links nach rechts gelesen zum Kellerspeicher hinzugefügt. Häufig ist daher $k_0 = k_1$, um nur $k_2$ hinzuzufügen. Die Anzahl der hinzugefügten Kellerzeichen ist beliebig.}
	\end{figure}	
	
	\subsection{Mengenlehre}
	
	\subsubsection{Zeichen und ihre Bedeutung}
	
	\begin{itemize}
		\item $\{a, b, c\}$: Beispiel für den Grundaufbau einer Menge: umschlossen von geschweiften Klammern und Elemente abgetrennt mit Komma (in der Mathematik häufig Semikolon)
		\item $A \backslash B$: $A$ und $B$ sind Mengen. $A \backslash B$ enthält alle Elemente, die $A$ enthält, $B$ aber nicht ("$A$ ohne $B$")
		\item $A \cup B$: Vereinigung ("$A$ vereinigt $B$"): $A \cup B$ enthält alle Elemente, die in $A$ enthält und zusätzlich alle, die $B$ enthält
		\item $A \cap B$: Schnittmenge ("$A$ schneidet $B$"): $a \cap B$ enthält alle Elemente, die sowohl in $A$ als auch in $B$ enthalten sind
		\item $A \subseteq B$: Teilmenge: alle Elemente, die in $A$ enthalten sind, sind auch in $B$ enthalten. Die Mengen dürfen auch gleich sein (ansonsten wird $\subset$ genutzt)
		\item Potenzmenge $Pot(A)$: Menge aller Teilmengen von $A$. Dies sind $2^Q$ wenn $Q$ die Anzahl der Elemente in $A$ ist
	\end{itemize}

	\section{Netzwerke}
	\subsection{Adressen}
	Damit mehrere Geräte in einem Netzwerk kommunizieren können, müssen sie wissen, wie sie sich ansprechen können. Dies funktioniert über das \textit{Internet Protocol} (IP). Damit ein Computer weiß, wo es einen anderen Computer finden kann, gehört zu jedem Computer in einem Netzwerk eine IP-Adresse. Diese IP-Adresse ist quasi der Standort des Computers im Netzwerk, ähnlich wie eine Kombination aus Straße und Hausnummer in der menschlichen Welt (wobei eine IP-Adresse allerings \textbf{nicht} direkt auf eine physische Adresse zurückzuführen ist). Da ein Computer allerdings mehrere Verbindungen gleichzeitig verarbeiten kann, benötigt die Netzwerkkommunikation  auch noch sogenannte \textit{Ports}. Diese sind vergleichbar mit Türen oder Briefkästen eines hauses. Beispielsweise spricht man bei Netzwerken analog zum "Haupteingang der Adresse Hans-Brückmann-Str. 1" vom Port 8080 der Adresse 187.214.3.99.

	\subsubsection{IP-Adressen}
	Der noch-Standard bei den Internetadressen heißt "IPv4". Solche Adressen bestehen aus 4 Blöcken mit den Zahlen 0 bis 255. Folglich hat man 4 Blöcke mit 256 Zahlen, über die man einen COmputer in einem Netzwerk ansprechen kann.

	\paragraph{Localhost}
	Wenn man eine Verbindung zu einem anderen Programm auf dem eigenen Computer aufbauen möchte, kann man dies über den Hostname "localhost" oder die IP-Adresse "127.0.0.1" tun.

	\subsubsection{Ports}
	Eine Verbidnung in einem Netzwerk wird immer von einem Port zu einem anderen aufgebaut. Gültige Portnummern sind 0 bis 65.535. 
	
	\paragraph{System ports}
	Die Ports 0 bis 1023 sind in der Regel für bestimmte Netzwerkdienste reserviert und sollten ihrer Spezifikation entsprechend verwendet werden. Der Port 80 ist beispielsweise der Standard für unverschlüsselte HTTP-Verbindungen (Webseitenbereitstellung), Port 22 ist reserviert für SSH-Verbindungen (Fernwartung von Computern). Eine Liste an standardisierten Ports ist auf \href{https://de.wikipedia.org/wiki/Liste_der_standardisierten_Ports}{\underline{Wikipedia}} zu finden.

	\paragraph{Dynamic ports}
	Die Ports über 49152 sollten in der Regel von Clients zum Verbindungsaufbau mit Servern reserviert sein.

	\subsection{Client-Server-Architektur}
	Eine weit verbreitete Methode zum Datenaustausch in Netzwerken ist die sogenannte Client-Server-Architektur. Hierbei verbinden sich mehrere Clients mit einem zentralen Server. Der Server kann hierbei entweder Daten für die einzelnen Clients bereitstellen (etwa ein Server, der die aktuelle Uhrzeit bereitstellt), oder den Datenaustausch zwischen einzelnen Clients managen (etwa der Server eines Messengers oder ein Emailserver). Diese Form eines Netzwerkservices ist im Alltag an vielen Stellen anzufinden, etwa:

	\begin{itemize}
		\item Das Aufrufen einer Webseite auf einem Webserver (Browser als Client, Webserver als Server)
		\item Videospiele (Spiele auf einzelnen Computern als Client, Gameserver als Server)
		\item Email (Email-Programm/Browser als Client, Email-Server (bspw gmail) als Server)
	\end{itemize}

	\subsubsection{Implementation in Java}
	Zur Implementation einer Client-Server-Architektur in Java sind die abstrakten Klassen \textit{Client} und \textit{Server} sowie die Klasse \textit{Connection} vorgegeben. Alle dieser Klassen arbeiten im Hintergrund über die Java-Socket-API, die quasi die hardwarenaheste Netzwerkimplementation in Java darstellt.

	\paragraph{Client}
	Ein implementierter Client erbt von der abstrakten \textit{Client}-Klasse und implementiert mindestens die Methode \textit{processMessage} sowie den Konstruktor. Über den Konstruktor der abstrakten \textit{Client}-Klasse kann der Client mit einer IP-Adresse und einem Port eine Verbindung zu einem Server aufbauen. Die \textit{processMessage}-methode wird jedes mal aufgerufen, wenn der verbundende Server eine Nachricht an den Client schickt. 

	\paragraph{Server}
	Um einen Server zu implementieren, erstellt man eine neue Klasse, die von der abstrakten \textit{Server}-Klasse erbt. Diese Klasse muss die Methoden \textit{processNewConnection}, \textit{processMessage} und \textit{processClosingConnection} sowie den Konstruktor implementieren:

	\subparagraph{Konstruktor}
	Dem Konstruktor muss ein Port als Integer übergeben werden. Die Server-Klasse öffnet dann diesen Port für neue Verbindungen.

	\subparagraph{processNewConnection}
	Die Methode \textit{processNewConnection(String pClientIP, int pClientPort)} wird jedes Mal aufgerufen, wenn sich ein neuer Client mit dem erstellten Server verbindet. Die übergebenen Parameter sind Informationen über den verbindenden Client, mit denen dieser eindeutig identifizierbar ist, etwa, falls man eine Nachricht an diesen Client senden möchte - etwa übr die \textit{send}-Methode des abstrakten Servers.

	\subparagraph{processMessage}
	Die Methode \textit{processMessage(String pClientIP, int pClientPort, String pMessage)} wird jedes Mal ausgeführt, wenn ein verbundender Client eine Nachricht an den Server schickt. Neben den Informationen über den Client enthalten die Parameter auch die übermittelte Nachricht.

	\subparagraph{processClosingConnection}
	Über die Methode \textit{processClosingConnection(String pClientIP, int pClientPort)} wir mitgeteilt, wenn eine Verbindung zu einem Client entweder von diesem Client oder durch den Server geschlossen wurde. Auch hier werden wieder die Verbindungsinformationen des Clients übergeben.

	\paragraph{Connection}
	Die \textit{Connection}-Klasse ist eine vereinfachte Client-Implementation ohne verschiedene Threads, die bei den anderen Klassen das Aufrufen der überschriebenen methoden übernehmen. Über die Methoden der \textit{Connection}-Klasse kann man Nachrichten an den Server senden (\textit{send}), Nachrichten empfangen (\textit{receive}) und die Verbindung beenden (\textit{close}). Die Verbindung wird im Konstruktor aufgebaut, dem auch wieder die IP-Adresse und der Port eines wartenden Servers übergeben werden müssen.

	\subsection{Netzwerkprotokolle}
	Um eine ordnungsgemäße Kommunikation im Netzwerk zu gewährleisten, wird auf sogenannte \textit{Protokolle} zurückgegriffen. Ein Netzwerkprotokoll gibt feste Regeln für Kommunikationsabläufe vor. So wird beispielsweise vorgeschrieben, welche Nachrichten ein Kommunikationsteilnehmer zu welcher Zeit akzeptiert, und wie er auf solche Nachrichten antworten soll.


	\section{Datenschutz}

\end{document}
